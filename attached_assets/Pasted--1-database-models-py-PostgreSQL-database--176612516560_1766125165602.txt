
1. üóÑÔ∏è –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –ë–∞–∑–∏ –î–∞–Ω–∏—Ö (database/models.py)
–¢—É—Ç –º–∏ —Å—Ç–≤–æ—Ä—é—î–º–æ —Ç–∞–±–ª–∏—Ü—ñ –≤ PostgreSQL.
# database/models.py
import logging
from config.database import execute_query

logger = logging.getLogger(__name__)

async def init_db():
    """–Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è —Ç–∞–±–ª–∏—Ü—å –±–∞–∑–∏ –¥–∞–Ω–∏—Ö"""
    try:
        # –¢–∞–±–ª–∏—Ü—è –±–æ—Ç—ñ–≤
        await execute_query("""
            CREATE TABLE IF NOT EXISTS bots (
                bot_id VARCHAR(50) PRIMARY KEY,
                phone_number VARCHAR(20) NOT NULL,
                session_string TEXT,
                proxy_config JSONB,
                status VARCHAR(20) DEFAULT 'active',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                last_active TIMESTAMP
            );
        """)

        # –¢–∞–±–ª–∏—Ü—è –∫–∞–º–ø–∞–Ω—ñ–π
        await execute_query("""
            CREATE TABLE IF NOT EXISTS campaigns (
                id VARCHAR(50) PRIMARY KEY,
                name VARCHAR(100),
                creator_id VARCHAR(50),
                project_id VARCHAR(50),
                status VARCHAR(20),
                recipients JSONB,
                messages JSONB,
                schedule JSONB,
                settings JSONB,
                stats JSONB,
                created_at TIMESTAMP,
                cancelled_at TIMESTAMP,
                error TEXT
            );
        """)
        
        # –¢–∞–±–ª–∏—Ü—è –ª–æ–≥—ñ–≤ –¥–æ—Å—Ç–∞–≤–∫–∏
        await execute_query("""
            CREATE TABLE IF NOT EXISTS delivery_logs (
                id SERIAL PRIMARY KEY,
                campaign_id VARCHAR(50),
                bot_id VARCHAR(50),
                recipient_type VARCHAR(20),
                recipient_value VARCHAR(100),
                message_id VARCHAR(50),
                success BOOLEAN,
                error TEXT,
                sent_at TIMESTAMP
            );
        """)

        # –¢–∞–±–ª–∏—Ü—è –ø—Ä–æ–∫—Å—ñ
        await execute_query("""
            CREATE TABLE IF NOT EXISTS proxies (
                proxy_id VARCHAR(50) PRIMARY KEY,
                type VARCHAR(10),
                host VARCHAR(50),
                port INTEGER,
                username VARCHAR(50),
                password VARCHAR(50),
                added_at TIMESTAMP,
                expires_at TIMESTAMP,
                status VARCHAR(20) DEFAULT 'active'
            );
        """)
        
        # –¢–∞–±–ª–∏—Ü—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤ –ø–∞—Ä—Å–∏–Ω–≥—É
        await execute_query("""
            CREATE TABLE IF NOT EXISTS parse_results (
                id SERIAL PRIMARY KEY,
                chat_id VARCHAR(50),
                chat_title VARCHAR(255),
                message_count INTEGER,
                users_count INTEGER,
                analysis_data JSONB,
                top_users JSONB,
                common_words JSONB,
                parsed_at TIMESTAMP
            );
        """)

        logger.info("Database tables initialized successfully")
    except Exception as e:
        logger.error(f"Failed to init DB: {e}")
        raise

2. üõ†Ô∏è CRUD –û–ø–µ—Ä–∞—Ü—ñ—ó (database/crud.py)
–§—É–Ω–∫—Ü—ñ—ó, —è–∫—ñ –≤–∏–∫–ª–∏–∫–∞—é—Ç—å—Å—è –≤ —Ç–≤–æ—ó—Ö —Å–∫—Ä–∏–ø—Ç–∞—Ö (create_bot, create_campaign —ñ —Ç.–¥.).
# database/crud.py
import json
from config.database import execute_query, fetchrow_query, fetch_query

# --- BOTS ---
async def create_bot(data: dict):
    query = """
        INSERT INTO bots (bot_id, phone_number, session_string, proxy_config, status, created_at)
        VALUES ($1, $2, $3, $4, $5, $6)
    """
    await execute_query(query, data['bot_id'], data['phone_number'], 
                        data['session_string'], data['proxy_config'], 
                        data['status'], data['created_at'])

# --- CAMPAIGNS ---
async def create_campaign(data: dict):
    query = """
        INSERT INTO campaigns (id, name, creator_id, project_id, status, recipients, messages, schedule, settings, stats, created_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
    """
    await execute_query(query, data['id'], data['name'], data['creator_id'], 
                        data.get('project_id'), data['status'], 
                        json.dumps(data['recipients']), json.dumps(data['messages']), 
                        json.dumps(data['schedule']), json.dumps(data['settings']), 
                        json.dumps(data['stats']), data['created_at'])

async def get_campaign(campaign_id: str):
    row = await fetchrow_query("SELECT * FROM campaigns WHERE id = $1", campaign_id)
    if row:
        data = dict(row)
        # –î–µ—Å–µ—Ä—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è JSON –ø–æ–ª—ñ–≤
        for field in ['recipients', 'messages', 'schedule', 'settings', 'stats']:
            if isinstance(data[field], str):
                data[field] = json.loads(data[field])
        return data
    return None

async def update_campaign(campaign_id: str, data: dict):
    # –î–∏–Ω–∞–º—ñ—á–Ω–µ —Å—Ç–≤–æ—Ä–µ–Ω–Ω—è SET —á–∞—Å—Ç–∏–Ω–∏ –∑–∞–ø–∏—Ç—É
    set_parts = []
    values = []
    idx = 1
    
    for key, value in data.items():
        if isinstance(value, (dict, list)):
            value = json.dumps(value)
        set_parts.append(f"{key} = ${idx}")
        values.append(value)
        idx += 1
    
    values.append(campaign_id)
    query = f"UPDATE campaigns SET {', '.join(set_parts)} WHERE id = ${idx}"
    
    await execute_query(query, *values)

async def list_campaigns(filters: dict, limit: int, offset: int):
    # –°–ø—Ä–æ—â–µ–Ω–∞ —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—è
    query = "SELECT * FROM campaigns LIMIT $1 OFFSET $2"
    rows = await fetch_query(query, limit, offset)
    return [dict(row) for row in rows]

# --- LOGS ---
async def create_delivery_log(data: dict):
    query = """
        INSERT INTO delivery_logs (campaign_id, bot_id, recipient_type, recipient_value, message_id, success, error, sent_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    """
    await execute_query(query, data['campaign_id'], data['bot_id'], 
                        data['recipient_type'], data['recipient_value'], 
                        data['message_id'], data['success'], 
                        data['error'], data['sent_at'])

async def get_delivery_stats(campaign_id: str):
    query = """
        SELECT 
            COUNT(*) as total,
            COUNT(*) FILTER (WHERE success = true) as delivered,
            COUNT(*) FILTER (WHERE success = false) as failed
        FROM delivery_logs 
        WHERE campaign_id = $1
    """
    row = await fetchrow_query(query, campaign_id)
    return dict(row) if row else {}

# --- PROXIES & PARSING ---
async def create_proxy(data: dict):
    query = """
        INSERT INTO proxies (proxy_id, type, host, port, username, password, added_at, expires_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    """
    await execute_query(query, data['proxy_id'], data['type'], data['host'], 
                        data['port'], data['username'], data['password'], 
                        data['added_at'], data['expires_at'])

async def create_parse_result(data: dict):
    query = """
        INSERT INTO parse_results (chat_id, chat_title, message_count, users_count, analysis_data, top_users, common_words, parsed_at)
        VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
    """
    await execute_query(query, data['chat_id'], data['chat_title'], 
                        data['message_count'], data['users_count'], 
                        json.dumps(data['analysis_data']), json.dumps(data['top_users']), 
                        json.dumps(data['common_words']), data['parsed_at'])

3. üöÄ –¢–æ—á–∫–∞ –í—Ö–æ–¥—É (main.py)
–§–∞–π–ª, —è–∫–∏–π –∑–∞–ø—É—Å–∫–∞—î –≤—Å—é —Ü—é —Å–∏—Å—Ç–µ–º—É.
# main.py
import asyncio
import logging
from config.settings import settings
from config.database import Database
from database.models import init_db
from core.bot_manager import bot_manager

# –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –ª–æ–≥—É–≤–∞–Ω–Ω—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("system.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

async def main():
    logger.info("üöÄ Starting SHADOW SYSTEM iO...")
    
    # 1. –ü—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è –¥–æ –ë–î
    try:
        await Database.get_pool()
        await Database.get_redis()
        await init_db()  # –°—Ç–≤–æ—Ä–µ–Ω–Ω—è —Ç–∞–±–ª–∏—Ü—å
        logger.info("‚úÖ Database connected and initialized")
    except Exception as e:
        logger.critical(f"‚ùå Database connection failed: {e}")
        return

    # 2. –ó–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è –±–æ—Ç—ñ–≤ –∑ –ë–î (–ø—Ä–∏–∫–ª–∞–¥ –ª–æ–≥—ñ–∫–∏ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è)
    # –¢—É—Ç –º–æ–∂–Ω–∞ –¥–æ–¥–∞—Ç–∏ –∫–æ–¥, —è–∫–∏–π –≤–∏—Ç—è–≥—É—î –∞–∫—Ç–∏–≤–Ω—ñ —Å–µ—Å—ñ—ó –∑ –ë–î —ñ —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É—î bot_manager
    
    # 3. –ó–∞–ø—É—Å–∫ –≤–µ–±-—Å–µ—Ä–≤–µ—Ä–∞ (—è–∫—â–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ webapp)
    # from webapp.app import start_web_server
    # asyncio.create_task(start_web_server())
    
    logger.info("üî• System is ready. Waiting for commands...")
    
    # –¢—Ä–∏–º–∞—î–º–æ –ø—Ä–æ—Ü–µ—Å –∂–∏–≤–∏–º
    try:
        while True:
            await asyncio.sleep(3600)
    except KeyboardInterrupt:
        logger.info("üõë Shutting down...")
        await Database.close()

if __name__ == "__main__":
    asyncio.run(main())


üìÅ –°–¢–†–£–ö–¢–£–†–ê –ü–†–û–ï–ö–¢–£

```
shadow_system_io/
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ settings.py
‚îÇ   ‚îú‚îÄ‚îÄ database.py
‚îÇ   ‚îî‚îÄ‚îÄ security.py
‚îú‚îÄ‚îÄ core/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ bot_manager.py
‚îÇ   ‚îú‚îÄ‚îÄ session_handler.py
‚îÇ   ‚îî‚îÄ‚îÄ proxy_manager.py
‚îú‚îÄ‚îÄ modules/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ parsing/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ geoscanner.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ chat_parser.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user_analyzer.py
‚îÇ   ‚îú‚îÄ‚îÄ messaging/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ campaign_manager.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ scheduler.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sender.py
‚îÇ   ‚îú‚îÄ‚îÄ hybrid/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ manager_interface.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ bot_switcher.py
‚îÇ   ‚îî‚îÄ‚îÄ analytics/
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ reporter.py
‚îÇ       ‚îî‚îÄ‚îÄ dashboard.py
‚îú‚îÄ‚îÄ database/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ models.py
‚îÇ   ‚îú‚îÄ‚îÄ crud.py
‚îÇ   ‚îî‚îÄ‚îÄ migrations/
‚îú‚îÄ‚îÄ webapp/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ app.py
‚îÇ   ‚îú‚îÄ‚îÄ routes.py
‚îÇ   ‚îî‚îÄ‚îÄ templates/
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ helpers.py
‚îÇ   ‚îú‚îÄ‚îÄ validators.py
‚îÇ   ‚îî‚îÄ‚îÄ decorators.py
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îú‚îÄ‚îÄ deploy.py
‚îÇ   ‚îî‚îÄ‚îÄ backup.py
‚îú‚îÄ‚îÄ .env
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ docker-compose.yml
‚îî‚îÄ‚îÄ main.py
```

üîß 1. –ö–û–ù–§–Ü–ì–£–†–ê–¶–Ü–Ø (config/)

config/settings.py

```python
import os
from pathlib import Path
from dotenv import load_dotenv

# –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –∑–º—ñ–Ω–Ω—ñ —Å–µ—Ä–µ–¥–æ–≤–∏—â–∞
load_dotenv()

BASE_DIR = Path(__file__).resolve().parent.parent

class Settings:
    # Telegram API
    API_ID = int(os.getenv("API_ID", ""))
    API_HASH = os.getenv("API_HASH", "")
    BOT_TOKEN = os.getenv("BOT_TOKEN", "")
    
    # Database
    POSTGRES_HOST = os.getenv("POSTGRES_HOST", "localhost")
    POSTGRES_PORT = int(os.getenv("POSTGRES_PORT", 5432))
    POSTGRES_DB = os.getenv("POSTGRES_DB", "shadow_system")
    POSTGRES_USER = os.getenv("POSTGRES_USER", "postgres")
    POSTGRES_PASSWORD = os.getenv("POSTGRES_PASSWORD", "")
    
    # Redis
    REDIS_HOST = os.getenv("REDIS_HOST", "localhost")
    REDIS_PORT = int(os.getenv("REDIS_PORT", 6379))
    REDIS_PASSWORD = os.getenv("REDIS_PASSWORD", "")
    
    # AI APIs
    OPENAI_API_KEY = os.getenv("OPENAI_API_KEY", "")
    GEMINI_API_KEY = os.getenv("GEMINI_API_KEY", "")
    
    # Security
    SECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key-change-this")
    ENCRYPTION_KEY = os.getenv("ENCRYPTION_KEY", "").encode()
    
    # Limits
    MESSAGES_PER_DAY = int(os.getenv("MESSAGES_PER_DAY", 100))
    PARALLEL_TASKS = int(os.getenv("PARALLEL_TASKS", 5))
    
    # Paths
    SESSIONS_DIR = BASE_DIR / "sessions"
    MEDIA_DIR = BASE_DIR / "media"
    LOGS_DIR = BASE_DIR / "logs"
    
    # Web App
    WEB_APP_URL = os.getenv("WEB_APP_URL", "https://your-webapp.vercel.app")
    
    def __init__(self):
        # –°—Ç–≤–æ—Ä—é—î–º–æ –¥–∏—Ä–µ–∫—Ç–æ—Ä—ñ—ó
        self.SESSIONS_DIR.mkdir(exist_ok=True)
        self.MEDIA_DIR.mkdir(exist_ok=True)
        self.LOGS_DIR.mkdir(exist_ok=True)

settings = Settings()
```

config/database.py

```python
import asyncpg
import redis.asyncio as redis
from contextlib import asynccontextmanager
from config.settings import settings
import logging

logger = logging.getLogger(__name__)

class Database:
    _pool = None
    _redis = None
    
    @classmethod
    async def get_pool(cls):
        if cls._pool is None:
            try:
                cls._pool = await asyncpg.create_pool(
                    host=settings.POSTGRES_HOST,
                    port=settings.POSTGRES_PORT,
                    user=settings.POSTGRES_USER,
                    password=settings.POSTGRES_PASSWORD,
                    database=settings.POSTGRES_DB,
                    min_size=5,
                    max_size=20
                )
                logger.info("Database pool created successfully")
            except Exception as e:
                logger.error(f"Failed to create database pool: {e}")
                raise
        return cls._pool
    
    @classmethod
    async def get_redis(cls):
        if cls._redis is None:
            try:
                cls._redis = redis.Redis(
                    host=settings.REDIS_HOST,
                    port=settings.REDIS_PORT,
                    password=settings.REDIS_PASSWORD,
                    decode_responses=True
                )
                await cls._redis.ping()
                logger.info("Redis connection established")
            except Exception as e:
                logger.error(f"Failed to connect to Redis: {e}")
                raise
        return cls._redis
    
    @classmethod
    @asynccontextmanager
    async def get_connection(cls):
        pool = await cls.get_pool()
        async with pool.acquire() as connection:
            yield connection
    
    @classmethod
    async def close(cls):
        if cls._pool:
            await cls._pool.close()
            cls._pool = None
        if cls._redis:
            await cls._redis.close()
            cls._redis = None

# –£—Ç–∏–ª—ñ—Ç–∏ –¥–ª—è —Ä–æ–±–æ—Ç–∏ –∑ –ë–î
async def execute_query(query, *args):
    async with Database.get_connection() as conn:
        return await conn.execute(query, *args)

async def fetch_query(query, *args):
    async with Database.get_connection() as conn:
        return await conn.fetch(query, *args)

async def fetchrow_query(query, *args):
    async with Database.get_connection() as conn:
        return await conn.fetchrow(query, *args)
```

ü§ñ 2. –Ø–î–†–û –°–ò–°–¢–ï–ú–ò (core/)

core/bot_manager.py

```python
import asyncio
import logging
from telethon import TelegramClient
from telethon.sessions import StringSession
from typing import Dict, List, Optional
from datetime import datetime
import json
from config.settings import settings
from core.proxy_manager import ProxyManager

logger = logging.getLogger(__name__)

class BotManager:
    def __init__(self):
        self.bots: Dict[str, TelegramClient] = {}
        self.proxy_manager = ProxyManager()
        self.running_tasks = {}
        
    async def add_bot(self, phone_number: str, session_string: str = None, 
                      proxy_data: dict = None) -> dict:
        """–î–æ–¥–∞—î –Ω–æ–≤–æ–≥–æ –±–æ—Ç–∞ –¥–æ —Å–∏—Å—Ç–µ–º–∏"""
        try:
            # –ì–µ–Ω–µ—Ä—É—î–º–æ —É–Ω—ñ–∫–∞–ª—å–Ω–∏–π ID –¥–ª—è –±–æ—Ç–∞
            bot_id = f"bot_{phone_number[-6:]}_{int(datetime.now().timestamp())}"
            
            # –ù–∞–ª–∞—à—Ç–æ–≤—É—î–º–æ –ø—Ä–æ–∫—Å—ñ
            proxy = await self.proxy_manager.get_proxy(proxy_data)
            
            # –°—Ç–≤–æ—Ä—é—î–º–æ –∫–ª—ñ—î–Ω—Ç
            client = TelegramClient(
                session=StringSession(session_string) if session_string else None,
                api_id=settings.API_ID,
                api_hash=settings.API_HASH,
                device_model="iPhone 13 Pro",
                system_version="iOS 15.4",
                app_version="8.4",
                proxy=proxy
            )
            
            # –ó'—î–¥–Ω—É—î–º–æ—Å—å
            await client.connect()
            
            if not await client.is_user_authorized():
                # –ü–æ—Ç—Ä—ñ–±–Ω–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü—ñ—è
                await client.send_code_request(phone_number)
                return {
                    "status": "need_code",
                    "bot_id": bot_id,
                    "phone_code_hash": client.session.phone_code_hash
                }
            
            # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Å–µ—Å—ñ—é
            session_string = client.session.save()
            
            # –î–æ–¥–∞—î–º–æ –≤ –±–∞–∑—É –¥–∞–Ω–∏—Ö
            from database.models import Bot
            from database.crud import create_bot
            
            bot_data = {
                "bot_id": bot_id,
                "phone_number": phone_number,
                "session_string": session_string,
                "proxy_config": json.dumps(proxy_data) if proxy_data else None,
                "status": "active",
                "created_at": datetime.now()
            }
            
            await create_bot(bot_data)
            
            # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –≤ –ø–∞–º'—è—Ç—ñ
            self.bots[bot_id] = client
            
            logger.info(f"Bot {bot_id} added successfully")
            return {"status": "success", "bot_id": bot_id}
            
        except Exception as e:
            logger.error(f"Failed to add bot: {e}")
            return {"status": "error", "error": str(e)}
    
    async def send_code(self, bot_id: str, code: str) -> dict:
        """–ü—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è –∫–æ–¥—É –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü—ñ—ó"""
        try:
            # –¢—É—Ç –ª–æ–≥—ñ–∫–∞ –ø—ñ–¥—Ç–≤–µ—Ä–¥–∂–µ–Ω–Ω—è –∫–æ–¥—É
            # ...
            return {"status": "success"}
        except Exception as e:
            return {"status": "error", "error": str(e)}
    
    async def get_bot_status(self, bot_id: str) -> dict:
        """–û—Ç—Ä–∏–º—É—î —Å—Ç–∞—Ç—É—Å –±–æ—Ç–∞"""
        if bot_id not in self.bots:
            return {"status": "not_found"}
        
        try:
            client = self.bots[bot_id]
            is_connected = await client.is_connected()
            me = await client.get_me() if is_connected else None
            
            return {
                "status": "online" if is_connected else "offline",
                "username": me.username if me else None,
                "first_name": me.first_name if me else None,
                "last_online": datetime.now().isoformat()
            }
        except Exception as e:
            return {"status": "error", "error": str(e)}
    
    async def execute_task(self, bot_id: str, task_type: str, 
                          task_data: dict) -> dict:
        """–í–∏–∫–æ–Ω—É—î –∑–∞–≤–¥–∞–Ω–Ω—è —á–µ—Ä–µ–∑ –±–æ—Ç–∞"""
        if bot_id not in self.bots:
            return {"status": "error", "error": "Bot not found"}
        
        client = self.bots[bot_id]
        
        try:
            if task_type == "send_message":
                result = await self._send_message(client, task_data)
            elif task_type == "join_chat":
                result = await self._join_chat(client, task_data)
            elif task_type == "parse_chat":
                result = await self._parse_chat(client, task_data)
            else:
                return {"status": "error", "error": "Unknown task type"}
            
            # –õ–æ–≥—É—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            await self._log_task(bot_id, task_type, task_data, result)
            
            return result
            
        except Exception as e:
            logger.error(f"Task execution failed: {e}")
            return {"status": "error", "error": str(e)}
    
    async def _send_message(self, client: TelegramClient, data: dict) -> dict:
        """–ù–∞–¥—Å–∏–ª–∞—î –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è"""
        entity = await client.get_entity(data["chat_id"])
        message = await client.send_message(
            entity,
            data["text"],
            file=data.get("file"),
            reply_to=data.get("reply_to")
        )
        return {"message_id": message.id, "status": "sent"}
    
    async def _join_chat(self, client: TelegramClient, data: dict) -> dict:
        """–ü—Ä–∏—î–¥–Ω—É—î—Ç—å—Å—è –¥–æ —á–∞—Ç—É"""
        invite_link = data["invite_link"]
        chat = await client.join_chat(invite_link)
        return {"chat_id": chat.id, "title": chat.title}
    
    async def _parse_chat(self, client: TelegramClient, data: dict) -> dict:
        """–ü–∞—Ä—Å–∏—Ç—å —á–∞—Ç"""
        chat_id = data["chat_id"]
        limit = data.get("limit", 100)
        
        messages = []
        async for message in client.iter_messages(chat_id, limit=limit):
            messages.append({
                "id": message.id,
                "text": message.text,
                "date": message.date.isoformat(),
                "sender_id": message.sender_id,
                "views": message.views
            })
        
        return {"messages": messages, "count": len(messages)}
    
    async def _log_task(self, bot_id: str, task_type: str, 
                       task_data: dict, result: dict):
        """–õ–æ–≥—É—î –≤–∏–∫–æ–Ω–∞–Ω–Ω—è –∑–∞–≤–¥–∞–Ω–Ω—è"""
        from database.crud import create_task_log
        
        log_data = {
            "bot_id": bot_id,
            "task_type": task_type,
            "task_data": json.dumps(task_data),
            "result": json.dumps(result),
            "executed_at": datetime.now()
        }
        
        await create_task_log(log_data)
    
    async def warm_up_bot(self, bot_id: str) -> dict:
        """–ü—Ä–æ–≥—Ä—ñ–≤–∞—î –±–æ—Ç–∞ (—ñ–º—ñ—Ç—É—î –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å –ª—é–¥–∏–Ω–∏)"""
        if bot_id not in self.bots:
            return {"status": "error", "error": "Bot not found"}
        
        client = self.bots[bot_id]
        
        try:
            # –ß–∏—Ç–∞—î–º–æ –æ—Å—Ç–∞–Ω–Ω—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
            async for dialog in client.iter_dialogs(limit=10):
                try:
                    async for message in client.iter_messages(
                        dialog.entity, 
                        limit=3
                    ):
                        # –ü—Ä–æ—Å—Ç–æ —á–∏—Ç–∞—î–º–æ
                        await asyncio.sleep(1)
                except:
                    continue
            
            # –†–æ–±–∏–º–æ –≤–∏–ø–∞–¥–∫–æ–≤—ñ –¥—ñ—ó
            actions = [
                self._scroll_chats,
                self._read_channel,
                self._check_notifications
            ]
            
            for action in actions:
                await action(client)
                await asyncio.sleep(5)
            
            return {"status": "success", "message": "Bot warmed up"}
            
        except Exception as e:
            return {"status": "error", "error": str(e)}
    
    async def _scroll_chats(self, client: TelegramClient):
        """–Ü–º—ñ—Ç—É—î –ø—Ä–æ–≥–æ—Ä—Ç–∞–Ω–Ω—è —á–∞—Ç—ñ–≤"""
        async for dialog in client.iter_dialogs(limit=5):
            await asyncio.sleep(0.5)
    
    async def _read_channel(self, client: TelegramClient):
        """–ß–∏—Ç–∞—î –∫–∞–Ω–∞–ª"""
        try:
            # –ó–Ω–∞—Ö–æ–¥–∏–º–æ –ø–æ–ø—É–ª—è—Ä–Ω–∏–π –∫–∞–Ω–∞–ª
            result = await client.inline_query('Telegram', '')
            if result:
                await asyncio.sleep(2)
        except:
            pass
    
    async def _check_notifications(self, client: TelegramClient):
        """–ü–µ—Ä–µ–≤—ñ—Ä—è—î —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è"""
        # –Ü–º—ñ—Ç–∞—Ü—ñ—è –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ —Å–ø–æ–≤—ñ—â–µ–Ω—å
        await asyncio.sleep(1)

bot_manager = BotManager()
```

core/session_handler.py

```python
import asyncio
import logging
from typing import Optional, Dict
from datetime import datetime, timedelta
from config.settings import settings
from config.database import Database
import json
import hashlib

logger = logging.getLogger(__name__)

class SessionHandler:
    def __init__(self):
        self.active_sessions: Dict[str, dict] = {}
        self.session_timeout = timedelta(hours=24)
    
    async def create_session(self, user_id: str, role: str, 
                           project_id: Optional[str] = None) -> str:
        """–°—Ç–≤–æ—Ä—é—î –Ω–æ–≤—É —Å–µ—Å—ñ—é –¥–ª—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞"""
        # –ì–µ–Ω–µ—Ä—É—î–º–æ —Ç–æ–∫–µ–Ω —Å–µ—Å—ñ—ó
        token_data = f"{user_id}{datetime.now().isoformat()}{role}"
        session_token = hashlib.sha256(token_data.encode()).hexdigest()
        
        # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –≤ Redis
        redis = await Database.get_redis()
        session_data = {
            "user_id": user_id,
            "role": role,
            "project_id": project_id,
            "created_at": datetime.now().isoformat(),
            "last_activity": datetime.now().isoformat()
        }
        
        await redis.setex(
            f"session:{session_token}",
            int(self.session_timeout.total_seconds()),
            json.dumps(session_data)
        )
        
        # –î–æ–¥–∞—î–º–æ –≤ –∞–∫—Ç–∏–≤–Ω—ñ —Å–µ—Å—ñ—ó
        self.active_sessions[session_token] = session_data
        
        logger.info(f"Session created for user {user_id}")
        return session_token
    
    async def validate_session(self, session_token: str) -> Optional[dict]:
        """–ü–µ—Ä–µ–≤—ñ—Ä—è—î –≤–∞–ª—ñ–¥–Ω—ñ—Å—Ç—å —Å–µ—Å—ñ—ó"""
        # –°–ø–æ—á–∞—Ç–∫—É –ø–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤ –ø–∞–º'—è—Ç—ñ
        if session_token in self.active_sessions:
            session_data = self.active_sessions[session_token]
            # –û–Ω–æ–≤–ª—é—î–º–æ –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å
            session_data["last_activity"] = datetime.now().isoformat()
            return session_data
        
        # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤ Redis
        redis = await Database.get_redis()
        session_json = await redis.get(f"session:{session_token}")
        
        if not session_json:
            return None
        
        session_data = json.loads(session_json)
        
        # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Ç–∞–π–º–∞—É—Ç
        last_activity = datetime.fromisoformat(session_data["last_activity"])
        if datetime.now() - last_activity > self.session_timeout:
            await self.invalidate_session(session_token)
            return None
        
        # –û–Ω–æ–≤–ª—é—î–º–æ –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å
        session_data["last_activity"] = datetime.now().isoformat()
        await redis.setex(
            f"session:{session_token}",
            int(self.session_timeout.total_seconds()),
            json.dumps(session_data)
        )
        
        # –î–æ–¥–∞—î–º–æ –≤ –∞–∫—Ç–∏–≤–Ω—ñ —Å–µ—Å—ñ—ó
        self.active_sessions[session_token] = session_data
        
        return session_data
    
    async def invalidate_session(self, session_token: str):
        """–ê–Ω—É–ª—é—î —Å–µ—Å—ñ—é"""
        redis = await Database.get_redis()
        
        # –í–∏–¥–∞–ª—è—î–º–æ –∑ Redis
        await redis.delete(f"session:{session_token}")
        
        # –í–∏–¥–∞–ª—è—î–º–æ –∑ –ø–∞–º'—è—Ç—ñ
        if session_token in self.active_sessions:
            del self.active_sessions[session_token]
        
        logger.info(f"Session {session_token} invalidated")
    
    async def get_user_sessions(self, user_id: str) -> list:
        """–û—Ç—Ä–∏–º—É—î –≤—Å—ñ —Å–µ—Å—ñ—ó –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞"""
        redis = await Database.get_redis()
        
        # –®—É–∫–∞—î–º–æ –≤—Å—ñ —Å–µ—Å—ñ—ó –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
        # (–¶–µ —Å–ø—Ä–æ—â–µ–Ω–∞ —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—è, –≤ –ø—Ä–æ–¥–∞–∫—à–µ–Ω—ñ –ø–æ—Ç—Ä—ñ–±–µ–Ω —ñ–Ω–¥–µ–∫—Å)
        sessions = []
        
        # –û—Ç—Ä–∏–º—É—î–º–æ –≤—Å—ñ –∫–ª—é—á—ñ —Å–µ—Å—ñ–π
        keys = await redis.keys("session:*")
        
        for key in keys:
            session_json = await redis.get(key)
            if session_json:
                session_data = json.loads(session_json)
                if session_data["user_id"] == user_id:
                    sessions.append({
                        "token": key.split(":")[1],
                        "created_at": session_data["created_at"],
                        "last_activity": session_data["last_activity"]
                    })
        
        return sessions
    
    async def update_session_data(self, session_token: str, data: dict):
        """–û–Ω–æ–≤–ª—é—î –¥–∞–Ω—ñ —Å–µ—Å—ñ—ó"""
        session_data = await self.validate_session(session_token)
        if not session_data:
            return False
        
        # –û–Ω–æ–≤–ª—é—î–º–æ –¥–∞–Ω—ñ
        session_data.update(data)
        
        # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –≤ Redis
        redis = await Database.get_redis()
        await redis.setex(
            f"session:{session_token}",
            int(self.session_timeout.total_seconds()),
            json.dumps(session_data)
        )
        
        # –û–Ω–æ–≤–ª—é—î–º–æ –≤ –ø–∞–º'—è—Ç—ñ
        self.active_sessions[session_token] = session_data
        
        return True

session_handler = SessionHandler()
```

core/proxy_manager.py

```python
import asyncio
import logging
from typing import Optional, Dict, List
import aiohttp
from config.settings import settings
from config.database import Database
import json
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)

class ProxyManager:
    def __init__(self):
        self.proxy_pool: Dict[str, dict] = {}
        self.proxy_usage: Dict[str, int] = {}
        self.max_usage_per_proxy = 1000  # –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –∑–∞–ø–∏—Ç—ñ–≤ –Ω–∞ –ø—Ä–æ–∫—Å—ñ
        
    async def get_proxy(self, proxy_data: Optional[dict] = None) -> Optional[dict]:
        """–û—Ç—Ä–∏–º—É—î –ø—Ä–æ–∫—Å—ñ –¥–ª—è –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è"""
        if proxy_data:
            # –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ –Ω–∞–¥–∞–Ω–∏–π –ø—Ä–æ–∫—Å—ñ
            return self._format_proxy(proxy_data)
        
        # –®—É–∫–∞—î–º–æ –≤—ñ–ª—å–Ω–∏–π –ø—Ä–æ–∫—Å—ñ –∑ –ø—É–ª—É
        proxy_id = await self._get_available_proxy()
        if proxy_id:
            proxy = self.proxy_pool[proxy_id]
            
            # –û–Ω–æ–≤–ª—é—î–º–æ –ª—ñ—á–∏–ª—å–Ω–∏–∫ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
            self.proxy_usage[proxy_id] = self.proxy_usage.get(proxy_id, 0) + 1
            
            # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –Ω–µ –ø–µ—Ä–µ–≤–∏—â–µ–Ω–∏–π –ª—ñ–º—ñ—Ç
            if self.proxy_usage[proxy_id] >= self.max_usage_per_proxy:
                await self._mark_proxy_as_expired(proxy_id)
            
            return self._format_proxy(proxy)
        
        # –Ø–∫—â–æ –Ω–µ–º–∞—î –≤—ñ–ª—å–Ω–∏—Ö –ø—Ä–æ–∫—Å—ñ, –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ None
        return None
    
    async def _get_available_proxy(self) -> Optional[str]:
        """–û—Ç—Ä–∏–º—É—î ID –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ –ø—Ä–æ–∫—Å—ñ"""
        # –°–ø–æ—á–∞—Ç–∫—É —à—É–∫–∞—î–º–æ –ø—Ä–æ–∫—Å—ñ –∑ –º—ñ–Ω—ñ–º–∞–ª—å–Ω–∏–º –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è–º
        available_proxies = []
        
        for proxy_id, proxy in self.proxy_pool.items():
            # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ –Ω–µ –∑–∞–∫—ñ–Ω—á–∏–≤—Å—è —Ç–µ—Ä–º—ñ–Ω –¥—ñ—ó
            if proxy.get("expires_at") and \
               datetime.fromisoformat(proxy["expires_at"]) < datetime.now():
                continue
            
            # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ –Ω–µ –ø–µ—Ä–µ–≤–∏—â–µ–Ω–∏–π –ª—ñ–º—ñ—Ç
            if self.proxy_usage.get(proxy_id, 0) >= self.max_usage_per_proxy:
                continue
            
            available_proxies.append((
                proxy_id,
                self.proxy_usage.get(proxy_id, 0),
                proxy.get("speed", 0)
            ))
        
        if not available_proxies:
            return None
        
        # –°–æ—Ä—Ç—É—î–º–æ –∑–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è–º (–º–µ–Ω—à–µ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–∏–π - –ø–µ—Ä—à–∏–π)
        available_proxies.sort(key=lambda x: x[1])
        
        return available_proxies[0][0]
    
    async def add_proxy(self, proxy_data: dict) -> str:
        """–î–æ–¥–∞—î –Ω–æ–≤–∏–π –ø—Ä–æ–∫—Å—ñ –¥–æ –ø—É–ª—É"""
        proxy_id = f"proxy_{int(datetime.now().timestamp())}_{hash(str(proxy_data)) % 10000}"
        
        # –¢–µ—Å—Ç—É—î–º–æ –ø—Ä–æ–∫—Å—ñ
        is_valid = await self._test_proxy(proxy_data)
        if not is_valid:
            raise ValueError("Proxy test failed")
        
        # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –ø—Ä–æ–∫—Å—ñ
        proxy_data["added_at"] = datetime.now().isoformat()
        proxy_data["tested_at"] = datetime.now().isoformat()
        
        # –Ø–∫—â–æ —î —Ç–µ—Ä–º—ñ–Ω –¥—ñ—ó
        if proxy_data.get("expiry_days"):
            expires_at = datetime.now() + timedelta(days=proxy_data["expiry_days"])
            proxy_data["expires_at"] = expires_at.isoformat()
        
        self.proxy_pool[proxy_id] = proxy_data
        self.proxy_usage[proxy_id] = 0
        
        # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –≤ –±–∞–∑—É –¥–∞–Ω–∏—Ö
        await self._save_proxy_to_db(proxy_id, proxy_data)
        
        logger.info(f"Proxy {proxy_id} added successfully")
        return proxy_id
    
    async def _test_proxy(self, proxy_data: dict) -> bool:
        """–¢–µ—Å—Ç—É—î –ø—Ä–∞—Ü–µ–∑–¥–∞—Ç–Ω—ñ—Å—Ç—å –ø—Ä–æ–∫—Å—ñ"""
        proxy_url = self._format_proxy_url(proxy_data)
        
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(
                    "https://api.telegram.org",
                    proxy=proxy_url,
                    timeout=aiohttp.ClientTimeout(total=10)
                ) as response:
                    return response.status == 200
        except:
            return False
    
    def _format_proxy(self, proxy_data: dict) -> dict:
        """–§–æ—Ä–º–∞—Ç—É—î –ø—Ä–æ–∫—Å—ñ –¥–ª—è Telethon"""
        proxy_type = proxy_data.get("type", "socks5")
        
        if proxy_type == "socks5":
            return {
                "proxy_type": "socks5",
                "addr": proxy_data["host"],
                "port": proxy_data["port"],
                "username": proxy_data.get("username"),
                "password": proxy_data.get("password")
            }
        elif proxy_type == "http":
            return {
                "proxy_type": "http",
                "addr": proxy_data["host"],
                "port": proxy_data["port"],
                "username": proxy_data.get("username"),
                "password": proxy_data.get("password")
            }
        else:
            raise ValueError(f"Unsupported proxy type: {proxy_type}")
    
    def _format_proxy_url(self, proxy_data: dict) -> str:
        """–§–æ—Ä–º–∞—Ç—É—î URL –ø—Ä–æ–∫—Å—ñ –¥–ª—è aiohttp"""
        proxy_type = proxy_data.get("type", "socks5")
        host = proxy_data["host"]
        port = proxy_data["port"]
        username = proxy_data.get("username")
        password = proxy_data.get("password")
        
        if username and password:
            auth = f"{username}:{password}@"
        else:
            auth = ""
        
        if proxy_type == "socks5":
            return f"socks5://{auth}{host}:{port}"
        elif proxy_type == "http":
            return f"http://{auth}{host}:{port}"
        else:
            raise ValueError(f"Unsupported proxy type: {proxy_type}")
    
    async def _save_proxy_to_db(self, proxy_id: str, proxy_data: dict):
        """–ó–±–µ—Ä—ñ–≥–∞—î –ø—Ä–æ–∫—Å—ñ –≤ –±–∞–∑—É –¥–∞–Ω–∏—Ö"""
        from database.crud import create_proxy
        
        db_data = {
            "proxy_id": proxy_id,
            "type": proxy_data.get("type", "socks5"),
            "host": proxy_data["host"],
            "port": proxy_data["port"],
            "username": proxy_data.get("username"),
            "password": proxy_data.get("password"),
            "added_at": proxy_data["added_at"],
            "expires_at": proxy_data.get("expires_at")
        }
        
        await create_proxy(db_data)
    
    async def _mark_proxy_as_expired(self, proxy_id: str):
        """–ü–æ–∑–Ω–∞—á–∞—î –ø—Ä–æ–∫—Å—ñ —è–∫ –ø—Ä–æ—Å—Ç—Ä–æ—á–µ–Ω–∏–π"""
        if proxy_id in self.proxy_pool:
            self.proxy_pool[proxy_id]["expires_at"] = datetime.now().isoformat()
            
            # –û–Ω–æ–≤–ª—é—î–º–æ –≤ –±–∞–∑—ñ –¥–∞–Ω–∏—Ö
            from database.crud import update_proxy
            
            await update_proxy(proxy_id, {
                "expires_at": datetime.now().isoformat(),
                "status": "expired"
            })
    
    async def get_proxy_stats(self) -> dict:
        """–û—Ç—Ä–∏–º—É—î —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ –ø—Ä–æ–∫—Å—ñ"""
        total = len(self.proxy_pool)
        active = 0
        expired = 0
        
        for proxy in self.proxy_pool.values():
            expires_at = proxy.get("expires_at")
            if expires_at and datetime.fromisoformat(expires_at) < datetime.now():
                expired += 1
            else:
                active += 1
        
        return {
            "total": total,
            "active": active,
            "expired": expired,
            "average_usage": sum(self.proxy_usage.values()) / total if total > 0 else 0
        }

proxy_manager = ProxyManager()
```

üîç 3. –ú–û–î–£–õ–¨ –ü–ê–†–°–ò–ù–ì–£ (modules/parsing/)

modules/parsing/geoscanner.py

```python
import asyncio
import logging
from typing import List, Dict, Optional
from datetime import datetime
import re
from telethon.tl.types import Channel, Chat
from telethon.tl.functions.messages import GetDialogsRequest
from telethon.tl.types import InputPeerEmpty
from config.settings import settings
from core.bot_manager import bot_manager

logger = logging.getLogger(__name__)

class GeoScanner:
    def __init__(self):
        self.cache = {}
        self.cache_timeout = 3600  # 1 –≥–æ–¥–∏–Ω–∞
        
    async def scan_by_location(self, location_keyword: str, 
                              limit: int = 50) -> Dict:
        """
        –°–∫–∞–Ω—É—î —á–∞—Ç–∏ –∑–∞ –∫–ª—é—á–æ–≤–∏–º —Å–ª–æ–≤–æ–º (–Ω–∞–∑–≤–∞ –º—ñ—Å—Ç–∞/—Ä–µ–≥—ñ–æ–Ω—É)
        
        Args:
            location_keyword: –ù–∞–∑–≤–∞ –º—ñ—Å—Ç–∞ (–Ω–∞–ø—Ä–∏–∫–ª–∞–¥, "–ß–µ—Ä–Ω—ñ–≤—Ü—ñ")
            limit: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å —á–∞—Ç—ñ–≤ –¥–ª—è –ø–æ—à—É–∫—É
            
        Returns:
            Dict –∑—ñ –∑–Ω–∞–π–¥–µ–Ω–∏–º–∏ —á–∞—Ç–∞–º–∏ —Ç–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–æ—é
        """
        try:
            # –û—Ç—Ä–∏–º—É—î–º–æ –±–æ—Ç–∞ –¥–ª—è —Å–∫–∞–Ω—É–≤–∞–Ω–Ω—è
            bot_id = await self._get_available_bot()
            if not bot_id:
                return {"error": "No available bots"}
            
            client = bot_manager.bots[bot_id]
            
            # –§–æ—Ä–º—É—î–º–æ –∫–ª—é—á–æ–≤—ñ —Å–ª–æ–≤–∞ –¥–ª—è –ø–æ—à—É–∫—É
            keywords = self._generate_keywords(location_keyword)
            
            all_chats = []
            
            # –®—É–∫–∞—î–º–æ —á–∞—Ç–∏ –∑–∞ –∫–æ–∂–Ω–∏–º –∫–ª—é—á–æ–≤–∏–º —Å–ª–æ–≤–æ–º
            for keyword in keywords:
                logger.info(f"Searching for chats with keyword: {keyword}")
                
                try:
                    # –í–∏–∫–æ–Ω—É—î–º–æ –ø–æ—à—É–∫
                    result = await client(GetDialogsRequest(
                        offset_date=None,
                        offset_id=0,
                        offset_peer=InputPeerEmpty(),
                        limit=limit,
                        hash=0
                    ))
                    
                    # –§—ñ–ª—å—Ç—Ä—É—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ –∑–∞ –∫–ª—é—á–æ–≤–∏–º —Å–ª–æ–≤–æ–º
                    chats = await self._filter_chats_by_keyword(
                        result.chats, 
                        keyword
                    )
                    
                    all_chats.extend(chats)
                    
                    await asyncio.sleep(2)  # –ó–∞—Ç—Ä–∏–º–∫–∞ –º—ñ–∂ –∑–∞–ø–∏—Ç–∞–º–∏
                    
                except Exception as e:
                    logger.error(f"Search failed for keyword {keyword}: {e}")
                    continue
            
            # –í–∏–¥–∞–ª—è—î–º–æ –¥—É–±–ª—ñ–∫–∞—Ç–∏
            unique_chats = self._remove_duplicates(all_chats)
            
            # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å
            analyzed_chats = []
            for chat in unique_chats[:20]:  # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ –ø–µ—Ä—à—ñ 20 —á–∞—Ç—ñ–≤
                chat_analysis = await self._analyze_chat(client, chat)
                analyzed_chats.append(chat_analysis)
            
            # –°–æ—Ä—Ç—É—î–º–æ –∑–∞ –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—é
            analyzed_chats.sort(key=lambda x: x.get('activity_score', 0), reverse=True)
            
            # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏
            result_data = {
                "location": location_keyword,
                "total_found": len(unique_chats),
                "analyzed": len(analyzed_chats),
                "chats": analyzed_chats[:10],  # –¢–æ–ø-10 —á–∞—Ç—ñ–≤
                "scan_date": datetime.now().isoformat(),
                "keywords_used": keywords
            }
            
            # –ö–µ—à—É—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏
            cache_key = f"geo_scan:{location_keyword}"
            self.cache[cache_key] = {
                "data": result_data,
                "timestamp": datetime.now().timestamp()
            }
            
            # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –≤ –±–∞–∑—É –¥–∞–Ω–∏—Ö
            await self._save_scan_results(result_data)
            
            return result_data
            
        except Exception as e:
            logger.error(f"Geo scan failed: {e}")
            return {"error": str(e)}
    
    def _generate_keywords(self, location: str) -> List[str]:
        """–ì–µ–Ω–µ—Ä—É—î –≤–∞—Ä—ñ–∞–Ω—Ç–∏ –∫–ª—é—á–æ–≤–∏—Ö —Å–ª—ñ–≤ –¥–ª—è –ø–æ—à—É–∫—É"""
        location_lower = location.lower()
        keywords = [
            location_lower,
            f"{location_lower} chat",
            f"{location_lower} group",
            f"{location_lower} –∫–∞–Ω–∞–ª",
            f"{location_lower} —á–∞—Ç",
            f"{location_lower} –≥—Ä—É–ø–∞",
            f"–º {location_lower}",
            f"–≥ {location_lower}",
            f"—á–∞—Ç {location_lower}",
            f"–≥—Ä—É–ø–∞ {location_lower}"
        ]
        
        # –î–æ–¥–∞—î–º–æ –≤–∞—Ä—ñ–∞–Ω—Ç–∏ –∑ —Ä—ñ–∑–Ω–∏–º–∏ –∑–∞–∫—ñ–Ω—á–µ–Ω–Ω—è–º–∏
        if location_lower.endswith("–∏"):
            base = location_lower[:-1]
            keywords.extend([f"{base}–∞", f"{base}—É", f"{base}—ñ"])
        
        return list(set(keywords))  # –í–∏–¥–∞–ª—è—î–º–æ –¥—É–±–ª—ñ–∫–∞—Ç–∏
    
    async def _filter_chats_by_keyword(self, chats: List, keyword: str) -> List[Dict]:
        """–§—ñ–ª—å—Ç—Ä—É—î —á–∞—Ç–∏ –∑–∞ –∫–ª—é—á–æ–≤–∏–º —Å–ª–æ–≤–æ–º"""
        filtered_chats = []
        
        for chat in chats:
            try:
                chat_title = getattr(chat, 'title', '').lower()
                chat_username = getattr(chat, 'username', '').lower()
                
                # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –∑–±—ñ–≥ —É –Ω–∞–∑–≤—ñ —á–∏ —é–∑–µ—Ä–Ω–µ–π–º—ñ
                if keyword in chat_title or keyword in chat_username:
                    chat_data = {
                        'id': chat.id,
                        'title': chat.title,
                        'username': chat.username,
                        'participants_count': getattr(chat, 'participants_count', 0),
                        'type': type(chat).__name__
                    }
                    filtered_chats.append(chat_data)
            except:
                continue
        
        return filtered_chats
    
    async def _analyze_chat(self, client, chat_data: Dict) -> Dict:
        """–ê–Ω–∞–ª—ñ–∑—É—î –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å —á–∞—Ç—É"""
        try:
            # –û—Ç—Ä–∏–º—É—î–º–æ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ —á–∞—Ç
            entity = await client.get_entity(chat_data['id'])
            
            # –û—Ç—Ä–∏–º—É—î–º–æ –æ—Å—Ç–∞–Ω–Ω—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
            messages = []
            message_count = 0
            async for message in client.iter_messages(entity, limit=50):
                message_count += 1
                messages.append({
                    'date': message.date.isoformat() if message.date else None,
                    'views': getattr(message, 'views', 0),
                    'replies': getattr(message, 'replies', 0)
                })
            
            # –†–æ–∑—Ä–∞—Ö–æ–≤—É—î–º–æ –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å
            activity_score = self._calculate_activity_score(messages)
            
            # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ —Ç–µ–º–∏
            themes = await self._extract_themes(client, entity)
            
            # –û—Ç—Ä–∏–º—É—î–º–æ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –∞–∫—Ç–∏–≤–Ω–∏—Ö —É—á–∞—Å–Ω–∏–∫—ñ–≤
            active_users = await self._get_active_users(client, entity)
            
            chat_data.update({
                'activity_score': activity_score,
                'message_count_analyzed': message_count,
                'themes': themes,
                'active_users_count': len(active_users),
                'top_active_users': active_users[:5],
                'last_activity': messages[0]['date'] if messages else None
            })
            
            return chat_data
            
        except Exception as e:
            logger.error(f"Chat analysis failed: {e}")
            chat_data['activity_score'] = 0
            chat_data['error'] = str(e)
            return chat_data
    
    def _calculate_activity_score(self, messages: List[Dict]) -> float:
        """–†–æ–∑—Ä–∞—Ö–æ–≤—É—î –±–∞–ª –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ —á–∞—Ç—É"""
        if not messages:
            return 0
        
        # –†–æ–∑—Ä–∞—Ö–æ–≤—É—î–º–æ —Å–µ—Ä–µ–¥–Ω—é –∫—ñ–ª—å–∫—ñ—Å—Ç—å –ø–µ—Ä–µ–≥–ª—è–¥—ñ–≤
        views = [msg.get('views', 0) for msg in messages]
        avg_views = sum(views) / len(views)
        
        # –†–æ–∑—Ä–∞—Ö–æ–≤—É—î–º–æ —Å–µ—Ä–µ–¥–Ω—é –∫—ñ–ª—å–∫—ñ—Å—Ç—å –≤—ñ–¥–ø–æ–≤—ñ–¥–µ–π
        replies = [msg.get('replies', 0) for msg in messages]
        avg_replies = sum(replies) / len(replies)
        
        # –ù–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ
        score = (avg_views / 1000) + (avg_replies * 2)
        
        return round(score, 2)
    
    async def _extract_themes(self, client, entity) -> List[str]:
        """–í–∏–∑–Ω–∞—á–∞—î –æ—Å–Ω–æ–≤–Ω—ñ —Ç–µ–º–∏ —á–∞—Ç—É"""
        try:
            themes = set()
            
            # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ –æ—Å—Ç–∞–Ω–Ω—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
            async for message in client.iter_messages(entity, limit=30):
                if message.text:
                    text_lower = message.text.lower()
                    
                    # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –Ω–∞—è–≤–Ω—ñ—Å—Ç—å –∫–ª—é—á–æ–≤–∏—Ö —Å–ª—ñ–≤
                    theme_keywords = {
                        '–Ω–æ–≤–∏–Ω–∏': ['–Ω–æ–≤–∏–Ω–∏', 'news', '–ø–æ–¥—ñ—è', '—Å–æ–±—ã—Ç–∏–µ'],
                        '—Ä–æ–∑–≤–∞–≥–∏': ['—Ä–æ–∑–≤–∞–≥–∏', '—Ä–æ–∑–≤–ª–µ—á–µ–Ω–∏—è', 'fun', 'music'],
                        '–±—ñ–∑–Ω–µ—Å': ['–±—ñ–∑–Ω–µ—Å', 'business', '—Ä–æ–±–æ—Ç–∞', '—Ä–∞–±–æ—Ç–∞'],
                        '–æ—Å–≤—ñ—Ç–∞': ['–æ—Å–≤—ñ—Ç–∞', '–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ', '–Ω–∞–≤—á–∞–Ω–Ω—è', '—É—á—ë–±–∞'],
                        '—Ç–µ—Ö–Ω–æ–ª–æ–≥—ñ—ó': ['—Ç–µ—Ö–Ω–æ–ª–æ–≥—ñ—ó', 'technology', '–ø—Ä–æ–≥—Ä–∞–º—É–≤–∞–Ω–Ω—è', 'programming']
                    }
                    
                    for theme, keywords in theme_keywords.items():
                        if any(keyword in text_lower for keyword in keywords):
                            themes.add(theme)
            
            return list(themes)[:5]  # –ù–µ –±—ñ–ª—å—à–µ 5 —Ç–µ–º
            
        except:
            return []
    
    async def _get_active_users(self, client, entity, limit: int = 20) -> List[Dict]:
        """–ó–Ω–∞—Ö–æ–¥–∏—Ç—å –Ω–∞–π–∞–∫—Ç–∏–≤–Ω—ñ—à–∏—Ö –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤"""
        try:
            user_activity = {}
            
            # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ –æ—Å—Ç–∞–Ω–Ω—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
            async for message in client.iter_messages(entity, limit=100):
                if message.sender_id:
                    sender_id = message.sender_id
                    user_activity[sender_id] = user_activity.get(sender_id, 0) + 1
            
            # –°–æ—Ä—Ç—É—î–º–æ –∑–∞ –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—é
            sorted_users = sorted(
                user_activity.items(), 
                key=lambda x: x[1], 
                reverse=True
            )[:limit]
            
            # –û—Ç—Ä–∏–º—É—î–º–æ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤
            active_users = []
            for user_id, message_count in sorted_users:
                try:
                    user = await client.get_entity(user_id)
                    active_users.append({
                        'id': user_id,
                        'username': user.username,
                        'first_name': user.first_name,
                        'last_name': user.last_name,
                        'messages_count': message_count
                    })
                except:
                    active_users.append({
                        'id': user_id,
                        'messages_count': message_count
                    })
            
            return active_users
            
        except:
            return []
    
    async def _get_available_bot(self) -> Optional[str]:
        """–û—Ç—Ä–∏–º—É—î –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ –±–æ—Ç–∞ –¥–ª—è —Å–∫–∞–Ω—É–≤–∞–Ω–Ω—è"""
        # –°–ø—Ä–æ—â–µ–Ω–∞ –ª–æ–≥—ñ–∫–∞ - –±–µ—Ä–µ–º–æ –ø–µ—Ä—à–æ–≥–æ –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ –±–æ—Ç–∞
        for bot_id, client in bot_manager.bots.items():
            if await client.is_connected():
                return bot_id
        return None
    
    async def _save_scan_results(self, results: Dict):
        """–ó–±–µ—Ä—ñ–≥–∞—î —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ —Å–∫–∞–Ω—É–≤–∞–Ω–Ω—è –≤ –±–∞–∑—É –¥–∞–Ω–∏—Ö"""
        from database.crud import create_scan_result
        
        scan_data = {
            "location": results["location"],
            "chats_found": results["total_found"],
            "top_chats": results["chats"],
            "scan_date": results["scan_date"],
            "keywords": results["keywords_used"]
        }
        
        await create_scan_result(scan_data)
    
    def _remove_duplicates(self, chats: List[Dict]) -> List[Dict]:
        """–í–∏–¥–∞–ª—è—î –¥—É–±–ª—ñ–∫–∞—Ç–∏ —á–∞—Ç—ñ–≤"""
        seen_ids = set()
        unique_chats = []
        
        for chat in chats:
            if chat['id'] not in seen_ids:
                seen_ids.add(chat['id'])
                unique_chats.append(chat)
        
        return unique_chats
    
    async def get_cached_scan(self, location: str) -> Optional[Dict]:
        """–û—Ç—Ä–∏–º—É—î –∑–∞–∫–µ—à–æ–≤–∞–Ω—ñ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ —Å–∫–∞–Ω—É–≤–∞–Ω–Ω—è"""
        cache_key = f"geo_scan:{location}"
        
        if cache_key in self.cache:
            cache_data = self.cache[cache_key]
            
            # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ –Ω–µ –ø—Ä–æ—Å—Ç—Ä–æ—á–µ–Ω—ñ
            cache_age = datetime.now().timestamp() - cache_data["timestamp"]
            if cache_age < self.cache_timeout:
                return cache_data["data"]
        
        return None

geo_scanner = GeoScanner()
```

modules/parsing/chat_parser.py

```python
import asyncio
import logging
from typing import List, Dict, Optional
from datetime import datetime, timedelta
import re
from collections import Counter
from telethon.tl.types import Message
from config.settings import settings
from core.bot_manager import bot_manager

logger = logging.getLogger(__name__)

class ChatParser:
    def __init__(self):
        self.active_parsers = {}
        self.message_cache = {}
    
    async def parse_chat_messages(self, chat_id: str, bot_id: str, 
                                 limit: int = 1000,
                                 time_frame: Optional[Dict] = None) -> Dict:
        """
        –ü–∞—Ä—Å–∏—Ç—å –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –∑ —á–∞—Ç—É
        
        Args:
            chat_id: ID —á–∞—Ç—É –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥—É
            bot_id: ID –±–æ—Ç–∞ –¥–ª—è –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
            limit: –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å
            time_frame: –ü–µ—Ä—ñ–æ–¥ —á–∞—Å—É –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥—É
            
        Returns:
            Dict –∑ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –ø–∞—Ä—Å–∏–Ω–≥—É
        """
        try:
            if bot_id not in bot_manager.bots:
                return {"error": "Bot not found"}
            
            client = bot_manager.bots[bot_id]
            
            # –û—Ç—Ä–∏–º—É—î–º–æ —Å—É—Ç–Ω—ñ—Å—Ç—å —á–∞—Ç—É
            try:
                entity = await client.get_entity(chat_id)
            except Exception as e:
                return {"error": f"Failed to get chat: {e}"}
            
            # –ù–∞–ª–∞—à—Ç–æ–≤—É—î–º–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥—É
            parse_params = self._prepare_parse_params(limit, time_frame)
            
            # –ü–∞—Ä—Å–∏–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
            messages = []
            users = {}
            message_count = 0
            
            async for message in client.iter_messages(
                entity,
                limit=parse_params['limit'],
                offset_date=parse_params['offset_date']
            ):
                message_data = await self._process_message(message)
                messages.append(message_data)
                message_count += 1
                
                # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
                if message.sender_id:
                    if message.sender_id not in users:
                        user_data = await self._extract_user_info(
                            client, 
                            message
                        )
                        users[message.sender_id] = user_data
                
                # –û–Ω–æ–≤–ª—é—î–º–æ –ø—Ä–æ–≥—Ä–µ—Å –∫–æ–∂–Ω—ñ 100 –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å
                if message_count % 100 == 0:
                    logger.info(f"Parsed {message_count} messages")
                    await asyncio.sleep(0.1)  # –ù–µ–≤–µ–ª–∏–∫–∞ –∑–∞—Ç—Ä–∏–º–∫–∞
            
            # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ –¥–∞–Ω—ñ
            analysis = await self._analyze_messages(messages, users)
            
            # –§–æ—Ä–º—É—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            result = {
                "chat_id": chat_id,
                "chat_title": entity.title if hasattr(entity, 'title') else str(chat_id),
                "total_messages": message_count,
                "time_period": {
                    "from": messages[-1]['date'] if messages else None,
                    "to": messages[0]['date'] if messages else None
                },
                "users_analyzed": len(users),
                "analysis": analysis,
                "top_active_users": self._get_top_users(users, messages)[:10],
                "common_words": self._get_common_words(messages)[:20],
                "parsed_at": datetime.now().isoformat()
            }
            
            # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏
            await self._save_parse_results(result)
            
            return result
            
        except Exception as e:
            logger.error(f"Chat parsing failed: {e}")
            return {"error": str(e)}
    
    def _prepare_parse_params(self, limit: int, 
                            time_frame: Optional[Dict]) -> Dict:
        """–ü—ñ–¥–≥–æ—Ç–æ–≤–ª—é—î –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –ø–∞—Ä—Å–∏–Ω–≥—É"""
        params = {'limit': limit}
        
        if time_frame:
            if 'days' in time_frame:
                offset_date = datetime.now() - timedelta(days=time_frame['days'])
                params['offset_date'] = offset_date
        
        return params
    
    async def _process_message(self, message: Message) -> Dict:
        """–û–±—Ä–æ–±–ª—è—î –æ–¥–Ω–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è"""
        message_data = {
            'id': message.id,
            'text': message.text or '',
            'date': message.date.isoformat() if message.date else None,
            'sender_id': message.sender_id,
            'views': getattr(message, 'views', 0),
            'replies': getattr(message, 'replies', 0),
            'forwards': getattr(message, 'forwards', 0),
            'media': bool(message.media),
            'reactions': self._extract_reactions(message)
        }
        
        # –î–æ–¥–∞—Ç–∫–æ–≤—ñ –ø–æ–ª—è –¥–ª—è –∞–Ω–∞–ª—ñ–∑—É
        message_data['word_count'] = len(message_data['text'].split())
        message_data['has_links'] = bool(re.findall(r'http[s]?://\S+', message_data['text']))
        message_data['has_mentions'] = bool(re.findall(r'@\w+', message_data['text']))
        
        return message_data
    
    def _extract_reactions(self, message: Message) -> Dict:
        """–í–∏—Ç—è–≥—É—î —Ä–µ–∞–∫—Ü—ñ—ó –∑ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è"""
        reactions = {}
        
        try:
            if hasattr(message, 'reactions') and message.reactions:
                for reaction in message.reactions.results:
                    reactions[reaction.reaction.emoticon] = reaction.count
        except:
            pass
        
        return reactions
    
    async def _extract_user_info(self, client, message: Message) -> Dict:
        """–í–∏—Ç—è–≥—É—î —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞"""
        try:
            user = await client.get_entity(message.sender_id)
            
            user_data = {
                'id': user.id,
                'username': user.username,
                'first_name': user.first_name,
                'last_name': user.last_name,
                'phone': getattr(user, 'phone', None),
                'bot': user.bot if hasattr(user, 'bot') else False,
                'verified': getattr(user, 'verified', False),
                'premium': getattr(user, 'premium', False)
            }
            
            return user_data
            
        except Exception as e:
            logger.warning(f"Failed to get user info: {e}")
            return {
                'id': message.sender_id,
                'error': str(e)
            }
    
    async def _analyze_messages(self, messages: List[Dict], 
                               users: Dict) -> Dict:
        """–ê–Ω–∞–ª—ñ–∑—É—î –≤—Å—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è"""
        if not messages:
            return {}
        
        # –ë–∞–∑–æ–≤–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        total_messages = len(messages)
        total_words = sum(m.get('word_count', 0) for m in messages)
        total_views = sum(m.get('views', 0) for m in messages)
        
        # –ê–Ω–∞–ª—ñ–∑ –∑–∞ —á–∞—Å–æ–º
        hourly_activity = self._analyze_hourly_activity(messages)
        daily_activity = self._analyze_daily_activity(messages)
        
        # –ê–Ω–∞–ª—ñ–∑ –∫–æ–Ω—Ç–µ–Ω—Ç—É
        content_analysis = self._analyze_content(messages)
        
        # –ê–Ω–∞–ª—ñ–∑ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤
        user_activity = self._analyze_user_activity(messages)
        
        return {
            'basic_stats': {
                'total_messages': total_messages,
                'total_words': total_words,
                'average_words_per_message': round(total_words / total_messages, 2),
                'average_views_per_message': round(total_views / total_messages, 2) if total_messages > 0 else 0,
                'messages_with_media': sum(1 for m in messages if m.get('media')),
                'messages_with_links': sum(1 for m in messages if m.get('has_links')),
                'messages_with_mentions': sum(1 for m in messages if m.get('has_mentions'))
            },
            'time_analysis': {
                'hourly_activity': hourly_activity,
                'daily_activity': daily_activity,
                'peak_hour': max(hourly_activity, key=hourly_activity.get) if hourly_activity else None,
                'peak_day': max(daily_activity, key=daily_activity.get) if daily_activity else None
            },
            'content_analysis': content_analysis,
            'user_analysis': user_activity
        }
    
    def _analyze_hourly_activity(self, messages: List[Dict]) -> Dict[int, int]:
        """–ê–Ω–∞–ª—ñ–∑—É—î –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å –ø–æ –≥–æ–¥–∏–Ω–∞—Ö"""
        hourly = {hour: 0 for hour in range(24)}
        
        for message in messages:
            if message.get('date'):
                try:
                    hour = datetime.fromisoformat(message['date']).hour
                    hourly[hour] = hourly.get(hour, 0) + 1
                except:
                    continue
        
        return hourly
    
    def _analyze_daily_activity(self, messages: List[Dict]) -> Dict[str, int]:
        """–ê–Ω–∞–ª—ñ–∑—É—î –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å –ø–æ –¥–Ω—è—Ö —Ç–∏–∂–Ω—è"""
        days = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 
                'Friday', 'Saturday', 'Sunday']
        daily = {day: 0 for day in days}
        
        for message in messages:
            if message.get('date'):
                try:
                    day = datetime.fromisoformat(message['date']).strftime('%A')
                    daily[day] = daily.get(day, 0) + 1
                except:
                    continue
        
        return daily
    
    def _analyze_content(self, messages: List[Dict]) -> Dict:
        """–ê–Ω–∞–ª—ñ–∑—É—î –∫–æ–Ω—Ç–µ–Ω—Ç –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å"""
        all_text = ' '.join(m.get('text', '') for m in messages)
        
        # –ó–Ω–∞—Ö–æ–¥–∏–º–æ –ø–æ–ø—É–ª—è—Ä–Ω—ñ —Å–ª–æ–≤–∞ (–±–µ–∑ —Å—Ç–æ–ø-—Å–ª—ñ–≤)
        words = re.findall(r'\b\w{3,}\b', all_text.lower())
        
        # –°–ø–∏—Å–æ–∫ —Å—Ç–æ–ø-—Å–ª—ñ–≤
        stop_words = {
            '—â–æ', '—è–∫', '–¥–µ', '–∫—É–¥–∏', '—á–æ–º—É', '—Ö—Ç–æ', '—Ü–µ', '—Ç–∞',
            '—ñ', '–≤', '–Ω–∞', '–∑', '–¥–æ', '–∑–∞', '—É', '–¥–ª—è', '–ø—Ä–æ',
            '—Ç–∞–∫', '–Ω—ñ', '–Ω–µ', '–∞–ª–µ', '–∞', '—Ç–æ', '–∂', '–±–æ', '—á–∏',
            'the', 'and', 'for', 'are', 'with', 'this', 'that'
        }
        
        filtered_words = [w for w in words if w not in stop_words]
        word_freq = Counter(filtered_words).most_common(50)
        
        # –ó–Ω–∞—Ö–æ–¥–∏–º–æ –ø–æ–ø—É–ª—è—Ä–Ω—ñ —Ö–µ—à—Ç–µ–≥–∏
        hashtags = re.findall(r'#\w+', all_text)
        hashtag_freq = Counter(hashtags).most_common(20)
        
        # –ó–Ω–∞—Ö–æ–¥–∏–º–æ –∑–≥–∞–¥—É–≤–∞–Ω–Ω—è
        mentions = re.findall(r'@\w+', all_text)
        mention_freq = Counter(mentions).most_common(20)
        
        return {
            'common_words': word_freq,
            'common_hashtags': hashtag_freq,
            'common_mentions': mention_freq,
            'total_unique_words': len(set(filtered_words)),
            'reading_level': self._estimate_reading_level(all_text)
        }
    
    def _estimate_reading_level(self, text: str) -> str:
        """–û—Ü—ñ–Ω—é—î —Ä—ñ–≤–µ–Ω—å —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ —Ç–µ–∫—Å—Ç—É"""
        words = text.split()
        if not words:
            return 'unknown'
        
        avg_word_len = sum(len(w) for w in words) / len(words)
        
        if avg_word_len < 4:
            return 'easy'
        elif avg_word_len < 6:
            return 'medium'
        else:
            return 'difficult'
    
    def _analyze_user_activity(self, messages: List[Dict]) -> Dict:
        """–ê–Ω–∞–ª—ñ–∑—É—î –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤"""
        user_message_count = {}
        
        for message in messages:
            sender_id = message.get('sender_id')
            if sender_id:
                user_message_count[sender_id] = \
                    user_message_count.get(sender_id, 0) + 1
        
        # –†–æ–∑—Ä–∞—Ö–æ–≤—É—î–º–æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
        if not user_message_count:
            return {}
        
        total_users = len(user_message_count)
        total_messages = sum(user_message_count.values())
        
        # –°–æ—Ä—Ç—É—î–º–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤ –∑–∞ –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—é
        sorted_users = sorted(
            user_message_count.items(),
            key=lambda x: x[1],
            reverse=True
        )
        
        # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ —Ä–æ–∑–ø–æ–¥—ñ–ª
        top_10_percent = sorted_users[:max(1, total_users // 10)]
        messages_by_top_10 = sum(count for _, count in top_10_percent)
        
        return {
            'total_users': total_users,
            'messages_per_user_avg': round(total_messages / total_users, 2),
            'top_user_id': sorted_users[0][0] if sorted_users else None,
            'top_user_messages': sorted_users[0][1] if sorted_users else 0,
            'top_10_percent_share': round(
                messages_by_top_10 / total_messages * 100, 2
            ) if total_messages > 0 else 0,
            'gini_coefficient': self._calculate_gini_coefficient(
                list(user_message_count.values())
            )
        }
    
    def _calculate_gini_coefficient(self, values: List[int]) -> float:
        """–†–æ–∑—Ä–∞—Ö–æ–≤—É—î –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç –î–∂–∏–Ω—ñ –¥–ª—è —Ä–æ–∑–ø–æ–¥—ñ–ª—É –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ"""
        if not values:
            return 0
        
        # –°–æ—Ä—Ç—É—î–º–æ –∑–Ω–∞—á–µ–Ω–Ω—è
        sorted_values = sorted(values)
        n = len(sorted_values)
        
        # –†–æ–∑—Ä–∞—Ö–æ–≤—É—î–º–æ –∫–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç –î–∂–∏–Ω—ñ
        cumulative_values = 0
        cumulative_index = 0
        
        for i, value in enumerate(sorted_values, 1):
            cumulative_values += value
            cumulative_index += i
        
        if cumulative_values == 0:
            return 0
        
        gini = (2 * cumulative_index) / (n * cumulative_values) - (n + 1) / n
        return round(gini, 3)
    
    def _get_top_users(self, users: Dict, messages: List[Dict]) -> List[Dict]:
        """–û—Ç—Ä–∏–º—É—î —Ç–æ–ø –∞–∫—Ç–∏–≤–Ω–∏—Ö –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤"""
        # –ü—ñ–¥—Ä–∞—Ö–æ–≤—É—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –∫–æ–∂–Ω–æ–≥–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
        user_message_count = {}
        
        for message in messages:
            sender_id = message.get('sender_id')
            if sender_id:
                user_message_count[sender_id] = \
                    user_message_count.get(sender_id, 0) + 1
        
        # –î–æ–¥–∞—î–º–æ –∫—ñ–ª—å–∫—ñ—Å—Ç—å –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å –¥–æ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—ó –ø—Ä–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
        top_users = []
        
        for sender_id, count in sorted(
            user_message_count.items(), 
            key=lambda x: x[1], 
            reverse=True
        )[:20]:  # –¢–æ–ø-20 –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤
            
            user_info = users.get(sender_id, {'id': sender_id})
            user_info['messages_count'] = count
            
            # –î–æ–¥–∞—î–º–æ —Å–µ—Ä–µ–¥–Ω—é –¥–æ–≤–∂–∏–Ω—É –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
            user_messages = [
                m for m in messages 
                if m.get('sender_id') == sender_id
            ]
            if user_messages:
                avg_words = sum(
                    m.get('word_count', 0) for m in user_messages
                ) / len(user_messages)
                user_info['avg_words_per_message'] = round(avg_words, 2)
            
            top_users.append(user_info)
        
        return top_users
    
    def _get_common_words(self, messages: List[Dict]) -> List[tuple]:
        """–û—Ç—Ä–∏–º—É—î –Ω–∞–π—á–∞—Å—Ç—ñ—à—ñ —Å–ª–æ–≤–∞"""
        all_text = ' '.join(m.get('text', '') for m in messages)
        words = re.findall(r'\b\w{3,}\b', all_text.lower())
        
        # –§—ñ–ª—å—Ç—Ä—É—î–º–æ —Å—Ç–æ–ø-—Å–ª–æ–≤–∞
        stop_words = {
            '—â–æ', '—è–∫', '–¥–µ', '–∫—É–¥–∏', '—á–æ–º—É', '—Ö—Ç–æ', '—Ü–µ', '—Ç–∞',
            '—ñ', '–≤', '–Ω–∞', '–∑', '–¥–æ', '–∑–∞', '—É', '–¥–ª—è', '–ø—Ä–æ',
            '—Ç–∞–∫', '–Ω—ñ', '–Ω–µ', '–∞–ª–µ', '–∞', '—Ç–æ', '–∂', '–±–æ', '—á–∏'
        }
        
        filtered_words = [w for w in words if w not in stop_words]
        word_freq = Counter(filtered_words)
        
        return word_freq.most_common(30)
    
    async def _save_parse_results(self, results: Dict):
        """–ó–±–µ—Ä—ñ–≥–∞—î —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ –ø–∞—Ä—Å–∏–Ω–≥—É –≤ –±–∞–∑—É –¥–∞–Ω–∏—Ö"""
        from database.crud import create_parse_result
        
        parse_data = {
            "chat_id": results["chat_id"],
            "chat_title": results.get("chat_title", ""),
            "message_count": results["total_messages"],
            "users_count": results.get("users_analyzed", 0),
            "analysis_data": results["analysis"],
            "top_users": results.get("top_active_users", []),
            "common_words": results.get("common_words", []),
            "parsed_at": results["parsed_at"]
        }
        
        await create_parse_result(parse_data)
    
    async def monitor_chat(self, chat_id: str, bot_id: str, 
                          callback_func) -> str:
        """
        –ó–∞–ø—É—Å–∫–∞—î –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ —á–∞—Ç—É –≤ —Ä–µ–∞–ª—å–Ω–æ–º—É —á–∞—Å—ñ
        
        Args:
            chat_id: ID —á–∞—Ç—É –¥–ª—è –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É
            bot_id: ID –±–æ—Ç–∞ –¥–ª—è –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
            callback_func: –§—É–Ω–∫—Ü—ñ—è –¥–ª—è –≤–∏–∫–ª–∏–∫—É –ø—Ä–∏ –Ω–æ–≤–∏—Ö –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è—Ö
            
        Returns:
            ID –∑–∞–¥–∞—á—ñ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É
        """
        task_id = f"monitor_{chat_id}_{int(datetime.now().timestamp())}"
        
        # –ó–∞–ø—É—Å–∫–∞—î–º–æ –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ –≤ –æ–∫—Ä–µ–º–æ–º—É –ø–æ—Ç–æ—Ü—ñ
        task = asyncio.create_task(
            self._run_monitoring(chat_id, bot_id, callback_func, task_id)
        )
        
        self.active_parsers[task_id] = {
            'task': task,
            'chat_id': chat_id,
            'bot_id': bot_id,
            'started_at': datetime.now().isoformat(),
            'status': 'running'
        }
        
        return task_id
    
    async def _run_monitoring(self, chat_id: str, bot_id: str, 
                            callback_func, task_id: str):
        """–ó–∞–ø—É—Å–∫–∞—î –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ —á–∞—Ç—É"""
        try:
            if bot_id not in bot_manager.bots:
                logger.error(f"Bot {bot_id} not found for monitoring")
                return
            
            client = bot_manager.bots[bot_id]
            entity = await client.get_entity(chat_id)
            
            # –û—Ç—Ä–∏–º—É—î–º–æ –æ—Å—Ç–∞–Ω–Ω—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è —è–∫ —Ç–æ—á–∫—É –≤—ñ–¥–ª—ñ–∫—É
            last_message_id = None
            async for message in client.iter_messages(entity, limit=1):
                last_message_id = message.id
                break
            
            logger.info(f"Starting monitoring for chat {chat_id}, last message: {last_message_id}")
            
            # –û—Å–Ω–æ–≤–Ω–∏–π —Ü–∏–∫–ª –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É
            while task_id in self.active_parsers:
                try:
                    # –û—Ç—Ä–∏–º—É—î–º–æ –Ω–æ–≤—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
                    new_messages = []
                    
                    async for message in client.iter_messages(
                        entity,
                        min_id=last_message_id,
                        limit=100
                    ):
                        if message.id > (last_message_id or 0):
                            message_data = await self._process_message(message)
                            new_messages.append(message_data)
                            
                            # –û–Ω–æ–≤–ª—é—î–º–æ ID –æ—Å—Ç–∞–Ω–Ω—å–æ–≥–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
                            last_message_id = max(
                                last_message_id or 0, 
                                message.id
                            )
                    
                    # –û–±—Ä–æ–±–ª—è—î–º–æ –Ω–æ–≤—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
                    if new_messages:
                        # –í–∏–∫–ª–∏–∫–∞—î–º–æ callback –∑ –Ω–æ–≤–∏–º–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º–∏
                        await callback_func({
                            'chat_id': chat_id,
                            'messages': new_messages,
                            'count': len(new_messages),
                            'timestamp': datetime.now().isoformat()
                        })
                    
                    # –ß–µ–∫–∞—î–º–æ –ø–µ—Ä–µ–¥ –Ω–∞—Å—Ç—É–ø–Ω–æ—é –ø–µ—Ä–µ–≤—ñ—Ä–∫–æ—é
                    await asyncio.sleep(10)  # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –∫–æ–∂–Ω—ñ 10 —Å–µ–∫—É–Ω–¥
                    
                except Exception as e:
                    logger.error(f"Monitoring iteration failed: {e}")
                    await asyncio.sleep(30)  # –ó–∞—Ç—Ä–∏–º–∫–∞ –ø—Ä–∏ –ø–æ–º–∏–ª—Ü—ñ
            
        except Exception as e:
            logger.error(f"Monitoring task failed: {e}")
        finally:
            # –ü—Ä–∏–±–∏—Ä–∞—î–º–æ –∑–∞–¥–∞—á—É –∑ –∞–∫—Ç–∏–≤–Ω–∏—Ö
            if task_id in self.active_parsers:
                del self.active_parsers[task_id]
    
    async def stop_monitoring(self, task_id: str) -> bool:
        """–ó—É–ø–∏–Ω—è—î –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ —á–∞—Ç—É"""
        if task_id in self.active_parsers:
            task_info = self.active_parsers[task_id]
            task_info['task'].cancel()
            del self.active_parsers[task_id]
            return True
        return False
    
    async def get_monitoring_status(self, task_id: str) -> Optional[Dict]:
        """–û—Ç—Ä–∏–º—É—î —Å—Ç–∞—Ç—É—Å –º–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥—É"""
        if task_id in self.active_parsers:
            task_info = self.active_parsers[task_id].copy()
            # –í–∏–¥–∞–ª—è—î–º–æ –æ–±'—î–∫—Ç –∑–∞–¥–∞—á—ñ (–Ω–µ —Å–µ—Ä—ñ–∞–ª—ñ–∑—É—î—Ç—å—Å—è)
            if 'task' in task_info:
                del task_info['task']
            return task_info
        return None

chat_parser = ChatParser()
```

modules/parsing/user_analyzer.py

```python
import asyncio
import logging
from typing import List, Dict, Optional
from datetime import datetime
import re
from collections import Counter
from config.settings import settings
from core.bot_manager import bot_manager

logger = logging.getLogger(__name__)

class UserAnalyzer:
    def __init__(self):
        self.user_profiles = {}
        self.behavior_patterns = {}
    
    async def analyze_user(self, user_id: str, bot_id: str, 
                          chat_id: Optional[str] = None) -> Dict:
        """
        –ê–Ω–∞–ª—ñ–∑—É—î –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –∑–∞ –π–æ–≥–æ ID
        
        Args:
            user_id: ID –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –¥–ª—è –∞–Ω–∞–ª—ñ–∑—É
            bot_id: ID –±–æ—Ç–∞ –¥–ª—è –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è
            chat_id: –û–ø—Ü—ñ–æ–Ω–∞–ª—å–Ω–∏–π ID —á–∞—Ç—É –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç—É
            
        Returns:
            Dict –∑ –∞–Ω–∞–ª—ñ–∑–æ–º –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
        """
        try:
            if bot_id not in bot_manager.bots:
                return {"error": "Bot not found"}
            
            client = bot_manager.bots[bot_id]
            
            # –û—Ç—Ä–∏–º—É—î–º–æ –æ—Å–Ω–æ–≤–Ω—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
            user_info = await self._get_user_info(client, user_id)
            
            if "error" in user_info:
                return user_info
            
            # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å
            activity_analysis = await self._analyze_activity(
                client, user_id, chat_id
            )
            
            # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ –∫–æ–Ω—Ç–µ–Ω—Ç
            content_analysis = await self._analyze_user_content(
                client, user_id, chat_id
            )
            
            # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ –ø–æ–≤–µ–¥—ñ–Ω–∫—É
            behavior_analysis = await self._analyze_behavior(
                client, user_id, chat_id
            )
            
            # –§–æ—Ä–º—É—î–º–æ –ø–æ–≤–Ω–∏–π –ø—Ä–æ—Ñ—ñ–ª—å
            user_profile = {
                **user_info,
                "activity": activity_analysis,
                "content": content_analysis,
                "behavior": behavior_analysis,
                "analysis_date": datetime.now().isoformat(),
                "risk_score": self._calculate_risk_score(
                    user_info, 
                    activity_analysis, 
                    behavior_analysis
                )
            }
            
            # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –ø—Ä–æ—Ñ—ñ–ª—å
            await self._save_user_profile(user_profile)
            
            # –ö–µ—à—É—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            cache_key = f"user_profile:{user_id}"
            self.user_profiles[cache_key] = {
                "data": user_profile,
                "timestamp": datetime.now().timestamp()
            }
            
            return user_profile
            
        except Exception as e:
            logger.error(f"User analysis failed: {e}")
            return {"error": str(e)}
    
    async def _get_user_info(self, client, user_id: str) -> Dict:
        """–û—Ç—Ä–∏–º—É—î –æ—Å–Ω–æ–≤–Ω—É —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—é –ø—Ä–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞"""
        try:
            user = await client.get_entity(user_id)
            
            # –ë–∞–∑–æ–≤–∞ —ñ–Ω—Ñ–æ—Ä–º–∞—Ü—ñ—è
            user_info = {
                "id": user.id,
                "username": user.username,
                "first_name": user.first_name,
                "last_name": user.last_name,
                "phone": getattr(user, 'phone', None),
                "bot": user.bot if hasattr(user, 'bot') else False,
                "verified": getattr(user, 'verified', False),
                "premium": getattr(user, 'premium', False),
                "restricted": getattr(user, 'restricted', False),
                "scam": getattr(user, 'scam', False),
                "fake": getattr(user, 'fake', False),
                "lang_code": getattr(user, 'lang_code', None),
                "mutual_contact": getattr(user, 'mutual_contact', False)
            }
            
            # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ —Å—Ç–∞—Ç—É—Å
            status = getattr(user, 'status', None)
            if status:
                user_info["status"] = type(status).__name__
                user_info["last_seen"] = self._extract_last_seen(status)
            
            # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ —Ñ–æ—Ç–æ –ø—Ä–æ—Ñ—ñ–ª—é
            try:
                photo = await client.download_profile_photo(user, file=bytes)
                if photo:
                    user_info["has_photo"] = True
                    user_info["photo_size"] = len(photo)
                else:
                    user_info["has_photo"] = False
            except:
                user_info["has_photo"] = False
            
            return user_info
            
        except Exception as e:
            logger.warning(f"Failed to get user info: {e}")
            return {"id": user_id, "error": str(e)}
    
    def _extract_last_seen(self, status) -> Optional[str]:
        """–í–∏—Ç—è–≥—É—î —á–∞—Å –æ—Å—Ç–∞–Ω–Ω—å–æ—ó –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ"""
        try:
            if hasattr(status, 'was_online'):
                return status.was_online.isoformat()
            elif hasattr(status, 'expires'):
                return status.expires.isoformat()
        except:
            pass
        return None
    
    async def _analyze_activity(self, client, user_id: str, 
                               chat_id: Optional[str]) -> Dict:
        """–ê–Ω–∞–ª—ñ–∑—É—î –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞"""
        try:
            # –Ø–∫—â–æ –≤–∫–∞–∑–∞–Ω–æ —á–∞—Ç - –∞–Ω–∞–ª—ñ–∑—É—î–º–æ –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å –≤ —á–∞—Ç—ñ
            if chat_id:
                return await self._analyze_chat_activity(
                    client, user_id, chat_id
                )
            else:
                # –ó–∞–≥–∞–ª—å–Ω–∞ –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å (–∞–Ω–∞–ª—ñ–∑—É—î–º–æ –æ—Å—Ç–∞–Ω–Ω—ñ –¥—ñ–∞–ª–æ–≥–∏)
                return await self._analyze_general_activity(client, user_id)
                
        except Exception as e:
            logger.warning(f"Activity analysis failed: {e}")
            return {"error": str(e)}
    
    async def _analyze_chat_activity(self, client, user_id: str, 
                                    chat_id: str) -> Dict:
        """–ê–Ω–∞–ª—ñ–∑—É—î –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –≤ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–º—É —á–∞—Ç—ñ"""
        try:
            entity = await client.get_entity(chat_id)
            
            # –û—Ç—Ä–∏–º—É—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
            user_messages = []
            async for message in client.iter_messages(
                entity,
                from_user=user_id,
                limit=200
            ):
                message_data = {
                    "id": message.id,
                    "date": message.date.isoformat() if message.date else None,
                    "text": message.text or "",
                    "views": getattr(message, 'views', 0),
                    "replies": getattr(message, 'replies', 0),
                    "forwards": getattr(message, 'forwards', 0)
                }
                user_messages.append(message_data)
            
            if not user_messages:
                return {"message_count": 0}
            
            # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ
            total_messages = len(user_messages)
            dates = [m["date"] for m in user_messages if m["date"]]
            
            # –†–æ–∑—Ä–∞—Ö–æ–≤—É—î–º–æ —á–∞—Å—Ç–æ—Ç—É –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å
            if len(dates) > 1:
                try:
                    first_date = datetime.fromisoformat(min(dates))
                    last_date = datetime.fromisoformat(max(dates))
                    days_active = (last_date - first_date).days or 1
                    messages_per_day = total_messages / days_active
                except:
                    messages_per_day = total_messages
            else:
                messages_per_day = total_messages
            
            # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ –∑–∞ —á–∞—Å–æ–º –¥–æ–±–∏
            hourly_activity = {hour: 0 for hour in range(24)}
            for message in user_messages:
                if message["date"]:
                    try:
                        hour = datetime.fromisoformat(message["date"]).hour
                        hourly_activity[hour] += 1
                    except:
                        pass
            
            # –ó–Ω–∞—Ö–æ–¥–∏–º–æ –ø—ñ–∫–æ–≤—ñ –≥–æ–¥–∏–Ω–∏
            peak_hours = [
                hour for hour, count in hourly_activity.items()
                if count == max(hourly_activity.values())
            ]
            
            return {
                "message_count": total_messages,
                "messages_per_day": round(messages_per_day, 2),
                "hourly_activity": hourly_activity,
                "peak_hours": peak_hours,
                "average_views": round(
                    sum(m.get("views", 0) for m in user_messages) / total_messages, 
                    2
                ) if total_messages > 0 else 0,
                "average_replies": round(
                    sum(m.get("replies", 0) for m in user_messages) / total_messages, 
                    2
                ) if total_messages > 0 else 0,
                "first_message": min(dates) if dates else None,
                "last_message": max(dates) if dates else None
            }
            
        except Exception as e:
            return {"error": str(e)}
    
    async def _analyze_general_activity(self, client, user_id: str) -> Dict:
        """–ê–Ω–∞–ª—ñ–∑—É—î –∑–∞–≥–∞–ª—å–Ω—É –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞"""
        # –°–ø—Ä–æ—â–µ–Ω–∞ —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—è - –º–æ–∂–Ω–∞ —Ä–æ–∑—à–∏—Ä–∏—Ç–∏
        return {
            "note": "General activity analysis requires more data",
            "suggested_action": "Analyze in specific chat context"
        }
    
    async def _analyze_user_content(self, client, user_id: str, 
                                   chat_id: Optional[str]) -> Dict:
        """–ê–Ω–∞–ª—ñ–∑—É—î –∫–æ–Ω—Ç–µ–Ω—Ç, —è–∫–∏–π –ø—É–±–ª—ñ–∫—É—î –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á"""
        try:
            if not chat_id:
                return {"note": "Content analysis requires chat context"}
            
            entity = await client.get_entity(chat_id)
            
            # –ó–±–∏—Ä–∞—î–º–æ —Ç–µ–∫—Å—Ç –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å
            all_text = ""
            async for message in client.iter_messages(
                entity,
                from_user=user_id,
                limit=100
            ):
                if message.text:
                    all_text += message.text + " "
            
            if not all_text.strip():
                return {"message": "No text content found"}
            
            # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ —Ç–µ–∫—Å—Ç
            words = re.findall(r'\b\w+\b', all_text.lower())
            total_words = len(words)
            
            if total_words == 0:
                return {"message": "No words found"}
            
            # –ó–Ω–∞—Ö–æ–¥–∏–º–æ —É–Ω—ñ–∫–∞–ª—å–Ω—ñ —Å–ª–æ–≤–∞
            unique_words = set(words)
            
            # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ –¥–æ–≤–∂–∏–Ω—É —Å–ª—ñ–≤
            avg_word_length = sum(len(w) for w in words) / total_words
            
            # –ó–Ω–∞—Ö–æ–¥–∏–º–æ –Ω–∞–π—á–∞—Å—Ç—ñ—à—ñ —Å–ª–æ–≤–∞
            word_freq = Counter(words).most_common(20)
            
            # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ —Ö–µ—à—Ç–µ–≥–∏ —Ç–∞ –∑–≥–∞–¥—É–≤–∞–Ω–Ω—è
            hashtags = re.findall(r'#\w+', all_text)
            mentions = re.findall(r'@\w+', all_text)
            
            # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ –ø–æ—Å–∏–ª–∞–Ω–Ω—è
            links = re.findall(r'https?://\S+', all_text)
            
            # –û—Ü—ñ–Ω—é—î–º–æ —Ç–æ–Ω–∞–ª—å–Ω—ñ—Å—Ç—å (—Å–ø—Ä–æ—â–µ–Ω–æ)
            sentiment = self._analyze_sentiment(all_text)
            
            # –í–∏–∑–Ω–∞—á–∞—î–º–æ —Ç–µ–º–∏
            topics = self._extract_topics(all_text)
            
            return {
                "total_words": total_words,
                "unique_words": len(unique_words),
                "vocabulary_richness": round(len(unique_words) / total_words, 3),
                "average_word_length": round(avg_word_length, 2),
                "common_words": word_freq,
                "hashtags": list(set(hashtags)),
                "mentions": list(set(mentions)),
                "links": list(set(links)),
                "sentiment": sentiment,
                "topics": topics,
                "reading_level": self._estimate_reading_level(all_text)
            }
            
        except Exception as e:
            logger.warning(f"Content analysis failed: {e}")
            return {"error": str(e)}
    
    def _analyze_sentiment(self, text: str) -> Dict:
        """–ê–Ω–∞–ª—ñ–∑—É—î —Ç–æ–Ω–∞–ª—å–Ω—ñ—Å—Ç—å —Ç–µ–∫—Å—Ç—É (—Å–ø—Ä–æ—â–µ–Ω–æ)"""
        # –°–ø–∏—Å–∫–∏ —Å–ª—ñ–≤ –¥–ª—è —Ä—ñ–∑–Ω–∏—Ö —Ç–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–µ–π
        positive_words = {
            '–¥–æ–±—Ä–µ', '—á—É–¥–æ–≤–æ', '—Å—É–ø–µ—Ä', '–∫–ª–∞—Å', '–ø–æ–¥–æ–±–∞—î—Ç—å—Å—è',
            '–ª—é–±–ª—é', '–≥–∞—Ä–Ω–æ', '–ø—Ä–µ–∫—Ä–∞—Å–Ω–æ', '–≤—ñ–¥–º—ñ–Ω–Ω–æ', '–∑–∞–¥–æ–≤–æ–ª–µ–Ω–∏–π',
            'good', 'great', 'excellent', 'awesome', 'love', 'like'
        }
        
        negative_words = {
            '–ø–æ–≥–∞–Ω–æ', '–∂–∞–ª—å–Ω–æ', '–≥—ñ–¥–Ω–æ', '–æ–≥–∏–¥–Ω–æ', '–Ω–µ–Ω–∞–≤–∏–¥–∂—É',
            '–Ω–µ–ø–æ–¥–æ–±–∞—î—Ç—å—Å—è', '—Å–æ—Ä–æ–º–Ω–æ', '–∂–∞—Ö–ª–∏–≤–æ', '–ø—Ä–æ–∫–ª—è—Ç—Ç—è',
            'bad', 'terrible', 'awful', 'hate', 'dislike', 'suck'
        }
        
        words = set(text.lower().split())
        
        positive_count = len(words.intersection(positive_words))
        negative_count = len(words.intersection(negative_words))
        
        total = positive_count + negative_count
        if total == 0:
            return {"score": 0, "label": "neutral"}
        
        score = (positive_count - negative_count) / total
        
        if score > 0.3:
            label = "positive"
        elif score < -0.3:
            label = "negative"
        else:
            label = "neutral"
        
        return {
            "score": round(score, 2),
            "label": label,
            "positive_words": positive_count,
            "negative_words": negative_count
        }
    
    def _extract_topics(self, text: str) -> List[str]:
        """–í–∏–∑–Ω–∞—á–∞—î –æ—Å–Ω–æ–≤–Ω—ñ —Ç–µ–º–∏ –≤ —Ç–µ–∫—Å—Ç—ñ"""
        # –ö–ª—é—á–æ–≤—ñ —Å–ª–æ–≤–∞ –¥–ª—è —Ç–µ–º
        topic_keywords = {
            '–Ω–æ–≤–∏–Ω–∏': ['–Ω–æ–≤–∏–Ω–∏', '–Ω–æ–≤–æ—Å—Ç—å', 'news', '–∑–≤—ñ—Ç', '—Ä–µ–ø–æ—Ä—Ç–∞–∂'],
            '—Ç–µ—Ö–Ω–æ–ª–æ–≥—ñ—ó': ['—Ç–µ—Ö–Ω–æ–ª–æ–≥—ñ—ó', '—Ç–µ—Ö–Ω–∏–∫–∞', '–≥–∞–¥–∂–µ—Ç', '–ø—Ä–æ–≥—Ä–∞–º–∞', '—Å–æ—Ñ—Ç'],
            '–ø–æ–ª—ñ—Ç–∏–∫–∞': ['–ø–æ–ª—ñ—Ç–∏–∫–∞', '—É—Ä—è–¥', '–≤–∏–±–æ—Ä–∏', '–∑–∞–∫–æ–Ω', '–ø–∞—Ä—Ç—ñ—è'],
            '—Å–ø–æ—Ä—Ç': ['—Å–ø–æ—Ä—Ç', '–º–∞—Ç—á', '–∫–æ–º–∞–Ω–¥–∞', '–ø–µ—Ä–µ–º–æ–≥–∞', '—á–µ–º–ø—ñ–æ–Ω–∞—Ç'],
            '—Ä–æ–∑–≤–∞–≥–∏': ['—Ä–æ–∑–≤–∞–≥–∏', '–∫—ñ–Ω–æ', '–º—É–∑–∏–∫–∞', '–∫–æ–Ω—Ü–µ—Ä—Ç', '—Ñ—ñ–ª—å–º'],
            '–±—ñ–∑–Ω–µ—Å': ['–±—ñ–∑–Ω–µ—Å', '–∫–æ–º–ø–∞–Ω—ñ—è', '—Ä–∏–Ω–æ–∫', '—ñ–Ω–≤–µ—Å—Ç–∏—Ü—ñ—ó', '–≥—Ä–æ—à—ñ'],
            '–æ—Å–≤—ñ—Ç–∞': ['–æ—Å–≤—ñ—Ç–∞', '—à–∫–æ–ª–∞', '—É–Ω—ñ–≤–µ—Ä—Å–∏—Ç–µ—Ç', '–Ω–∞–≤—á–∞–Ω–Ω—è', '—Å—Ç—É–¥–µ–Ω—Ç']
        }
        
        text_lower = text.lower()
        found_topics = []
        
        for topic, keywords in topic_keywords.items():
            if any(keyword in text_lower for keyword in keywords):
                found_topics.append(topic)
        
        return found_topics[:5]  # –ù–µ –±—ñ–ª—å—à–µ 5 —Ç–µ–º
    
    def _estimate_reading_level(self, text: str) -> str:
        """–û—Ü—ñ–Ω—é—î —Ä—ñ–≤–µ–Ω—å —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ —Ç–µ–∫—Å—Ç—É"""
        sentences = re.split(r'[.!?]+', text)
        words = text.split()
        
        if len(sentences) == 0 or len(words) == 0:
            return "unknown"
        
        avg_sentence_length = len(words) / len(sentences)
        avg_word_length = sum(len(w) for w in words) / len(words)
        
        if avg_sentence_length < 10 and avg_word_length < 5:
            return "easy"
        elif avg_sentence_length < 20 and avg_word_length < 6:
            return "medium"
        else:
            return "difficult"
    
    async def _analyze_behavior(self, client, user_id: str, 
                               chat_id: Optional[str]) -> Dict:
        """–ê–Ω–∞–ª—ñ–∑—É—î –ø–æ–≤–µ–¥—ñ–Ω–∫—É –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞"""
        try:
            if not chat_id:
                return {"note": "Behavior analysis requires chat context"}
            
            entity = await client.get_entity(chat_id)
            
            # –û—Ç—Ä–∏–º—É—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –¥–ª—è –∞–Ω–∞–ª—ñ–∑—É –ø–æ–≤–µ–¥—ñ–Ω–∫–∏
            messages = []
            async for message in client.iter_messages(
                entity,
                from_user=user_id,
                limit=200
            ):
                messages.append({
                    "date": message.date.isoformat() if message.date else None,
                    "text": message.text or "",
                    "replies": getattr(message, 'replies', 0)
                })
            
            if len(messages) < 10:
                return {"note": "Insufficient data for behavior analysis"}
            
            # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ —á–∞—Å–æ–≤—ñ –ø—Ä–æ–º—ñ–∂–∫–∏ –º—ñ–∂ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º–∏
            time_gaps = []
            for i in range(1, len(messages)):
                if messages[i]["date"] and messages[i-1]["date"]:
                    try:
                        dt1 = datetime.fromisoformat(messages[i]["date"])
                        dt2 = datetime.fromisoformat(messages[i-1]["date"])
                        gap = (dt1 - dt2).total_seconds() / 60  # –≤ —Ö–≤–∏–ª–∏–Ω–∞—Ö
                        if gap > 0:
                            time_gaps.append(gap)
                    except:
                        continue
            
            # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ —à–∞–±–ª–æ–Ω–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥–µ–π
            reply_patterns = self._analyze_reply_patterns(messages)
            
            # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å –∑–∞ –¥–Ω—è–º–∏ —Ç–∏–∂–Ω—è
            day_patterns = self._analyze_day_patterns(messages)
            
            return {
                "message_count": len(messages),
                "average_time_gap_minutes": round(
                    sum(time_gaps) / len(time_gaps), 2
                ) if time_gaps else None,
                "reply_rate": reply_patterns.get("reply_rate", 0),
                "most_active_day": day_patterns.get("most_active_day"),
                "activity_consistency": self._calculate_consistency(time_gaps),
                "behavior_pattern": self._identify_behavior_pattern(
                    time_gaps, reply_patterns, day_patterns
                )
            }
            
        except Exception as e:
            logger.warning(f"Behavior analysis failed: {e}")
            return {"error": str(e)}
    
    def _analyze_reply_patterns(self, messages: List[Dict]) -> Dict:
        """–ê–Ω–∞–ª—ñ–∑—É—î —à–∞–±–ª–æ–Ω–∏ –≤—ñ–¥–ø–æ–≤—ñ–¥–µ–π"""
        reply_keywords = ['–≤—ñ–¥–ø–æ–≤—ñ–¥—å', 'reply', 're', '>>', '>']
        
        reply_count = 0
        for message in messages:
            text = message["text"].lower()
            if any(keyword in text for keyword in reply_keywords):
                reply_count += 1
        
        return {
            "reply_count": reply_count,
            "reply_rate": round(reply_count / len(messages) * 100, 2) 
            if messages else 0
        }
    
    def _analyze_day_patterns(self, messages: List[Dict]) -> Dict:
        """–ê–Ω–∞–ª—ñ–∑—É—î –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å –∑–∞ –¥–Ω—è–º–∏ —Ç–∏–∂–Ω—è"""
        day_count = {day: 0 for day in [
            'Monday', 'Tuesday', 'Wednesday', 'Thursday',
            'Friday', 'Saturday', 'Sunday'
        ]}
        
        for message in messages:
            if message["date"]:
                try:
                    day = datetime.fromisoformat(message["date"]).strftime('%A')
                    day_count[day] += 1
                except:
                    continue
        
        most_active_day = max(day_count.items(), key=lambda x: x[1])[0] \
            if any(day_count.values()) else None
        
        return {
            "day_distribution": day_count,
            "most_active_day": most_active_day
        }
    
    def _calculate_consistency(self, time_gaps: List[float]) -> float:
        """–†–æ–∑—Ä–∞—Ö–æ–≤—É—î –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ñ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ"""
        if len(time_gaps) < 2:
            return 0
        
        # –ö–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç –≤–∞—Ä—ñ–∞—Ü—ñ—ó (–º–µ–Ω—à–µ = –±—ñ–ª—å—à–µ –∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω—ñ—Å—Ç—å)
        mean = sum(time_gaps) / len(time_gaps)
        variance = sum((x - mean) ** 2 for x in time_gaps) / len(time_gaps)
        std_dev = variance ** 0.5
        
        if mean == 0:
            return 0
        
        cv = std_dev / mean  # –ö–æ–µ—Ñ—ñ—Ü—ñ—î–Ω—Ç –≤–∞—Ä—ñ–∞—Ü—ñ—ó
        consistency = max(0, 1 - cv)  # –ù–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ –¥–æ 0-1
        
        return round(consistency, 3)
    
    def _identify_behavior_pattern(self, time_gaps: List[float],
                                  reply_patterns: Dict,
                                  day_patterns: Dict) -> str:
        """–Ü–¥–µ–Ω—Ç–∏—Ñ—ñ–∫—É—î —Ç–∏–ø –ø–æ–≤–µ–¥—ñ–Ω–∫–∏"""
        if not time_gaps:
            return "unknown"
        
        avg_gap = sum(time_gaps) / len(time_gaps)
        
        if avg_gap < 5:  # –ú–µ–Ω—à–µ 5 —Ö–≤–∏–ª–∏–Ω –º—ñ–∂ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º–∏
            return "active_spammer"
        elif avg_gap < 30:  # –ú–µ–Ω—à–µ 30 —Ö–≤–∏–ª–∏–Ω
            return "active_user"
        elif avg_gap < 120:  # 1-2 –≥–æ–¥–∏–Ω–∏
            if reply_patterns.get("reply_rate", 0) > 50:
                return "responsive_user"
            else:
                return "casual_user"
        elif avg_gap < 480:  # 4-8 –≥–æ–¥–∏–Ω
            return "periodic_user"
        else:
            return "rare_user"
    
    def _calculate_risk_score(self, user_info: Dict, 
                             activity: Dict, behavior: Dict) -> float:
        """–†–æ–∑—Ä–∞—Ö–æ–≤—É—î –±–∞–ª —Ä–∏–∑–∏–∫—É –¥–ª—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞"""
        score = 0.5  # –ë–∞–∑–æ–≤–∏–π –±–∞–ª
        
        # –§–∞–∫—Ç–æ—Ä–∏ –∑ user_info
        if user_info.get("scam"):
            score += 0.3
        if user_info.get("fake"):
            score += 0.2
        if user_info.get("restricted"):
            score += 0.1
        if not user_info.get("has_photo"):
            score += 0.05
        
        # –§–∞–∫—Ç–æ—Ä–∏ –∑ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ
        if activity.get("messages_per_day", 0) > 50:
            score += 0.1
        
        # –§–∞–∫—Ç–æ—Ä–∏ –∑ –ø–æ–≤–µ–¥—ñ–Ω–∫–∏
        behavior_pattern = behavior.get("behavior_pattern", "")
        if behavior_pattern == "active_spammer":
            score += 0.2
        elif behavior_pattern == "rare_user":
            score -= 0.1
        
        # –ù–æ—Ä–º–∞–ª—ñ–∑—É—î–º–æ –¥–æ 0-1
        score = max(0, min(1, score))
        
        return round(score, 3)
    
    async def _save_user_profile(self, profile: Dict):
        """–ó–±–µ—Ä—ñ–≥–∞—î –ø—Ä–æ—Ñ—ñ–ª—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –≤ –±–∞–∑—É –¥–∞–Ω–∏—Ö"""
        from database.crud import create_user_profile
        
        profile_data = {
            "user_id": profile["id"],
            "username": profile.get("username"),
            "profile_data": profile,
            "risk_score": profile.get("risk_score", 0),
            "analyzed_at": profile["analysis_date"]
        }
        
        await create_user_profile(profile_data)
    
    async def compare_users(self, user_ids: List[str], bot_id: str, 
                           chat_id: str) -> Dict:
        """–ü–æ—Ä—ñ–≤–Ω—é—î –¥–µ–∫—ñ–ª—å–∫–∞ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤"""
        profiles = []
        
        for user_id in user_ids:
            profile = await self.analyze_user(user_id, bot_id, chat_id)
            if "error" not in profile:
                profiles.append(profile)
        
        if not profiles:
            return {"error": "No valid profiles to compare"}
        
        # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ —Å—Ö–æ–∂—ñ—Å—Ç—å
        comparison = {
            "profiles_count": len(profiles),
            "profiles": profiles,
            "comparison_metrics": self._calculate_comparison_metrics(profiles),
            "similarity_matrix": self._calculate_similarity_matrix(profiles),
            "clusters": self._cluster_profiles(profiles)
        }
        
        return comparison
    
    def _calculate_comparison_metrics(self, profiles: List[Dict]) -> Dict:
        """–†–æ–∑—Ä–∞—Ö–æ–≤—É—î –º–µ—Ç—Ä–∏–∫–∏ –ø–æ—Ä—ñ–≤–Ω—è–Ω–Ω—è"""
        metrics = {}
        
        # –ê–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å
        activity_rates = [
            p.get("activity", {}).get("messages_per_day", 0)
            for p in profiles
        ]
        
        if activity_rates:
            metrics["avg_activity_rate"] = round(
                sum(activity_rates) / len(activity_rates), 2
            )
            metrics["max_activity_rate"] = round(max(activity_rates), 2)
            metrics["min_activity_rate"] = round(min(activity_rates), 2)
        
        # –†–∏–∑–∏–∫
        risk_scores = [p.get("risk_score", 0) for p in profiles]
        if risk_scores:
            metrics["avg_risk_score"] = round(
                sum(risk_scores) / len(risk_scores), 3
            )
            metrics["high_risk_users"] = sum(1 for s in risk_scores if s > 0.7)
        
        # –í—ñ–¥–Ω–æ—à–µ–Ω–Ω—è –±–æ—Ç—ñ–≤
        bot_count = sum(1 for p in profiles if p.get("bot", False))
        metrics["bot_percentage"] = round(
            bot_count / len(profiles) * 100, 2
        ) if profiles else 0
        
        return metrics
    
    def _calculate_similarity_matrix(self, profiles: List[Dict]) -> List[List[float]]:
        """–†–æ–∑—Ä–∞—Ö–æ–≤—É—î –º–∞—Ç—Ä–∏—Ü—é —Å—Ö–æ–∂–æ—Å—Ç—ñ"""
        n = len(profiles)
        matrix = [[0.0] * n for _ in range(n)]
        
        for i in range(n):
            for j in range(n):
                if i == j:
                    matrix[i][j] = 1.0
                elif i < j:
                    similarity = self._calculate_profile_similarity(
                        profiles[i], profiles[j]
                    )
                    matrix[i][j] = similarity
                    matrix[j][i] = similarity
        
        return matrix
    
    def _calculate_profile_similarity(self, profile1: Dict, 
                                     profile2: Dict) -> float:
        """–†–æ–∑—Ä–∞—Ö–æ–≤—É—î —Å—Ö–æ–∂—ñ—Å—Ç—å –º—ñ–∂ –¥–≤–æ–º–∞ –ø—Ä–æ—Ñ—ñ–ª—è–º–∏"""
        score = 0
        factors = 0
        
        # –°—Ö–æ–∂—ñ—Å—Ç—å –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ
        act1 = profile1.get("activity", {})
        act2 = profile2.get("activity", {})
        
        if act1 and act2:
            rate1 = act1.get("messages_per_day", 0)
            rate2 = act2.get("messages_per_day", 0)
            
            if rate1 > 0 and rate2 > 0:
                ratio = min(rate1, rate2) / max(rate1, rate2)
                score += ratio
                factors += 1
        
        # –°—Ö–æ–∂—ñ—Å—Ç—å –ø–æ–≤–µ–¥—ñ–Ω–∫–∏
        beh1 = profile1.get("behavior", {})
        beh2 = profile2.get("behavior", {})
        
        if beh1 and beh2:
            pattern1 = beh1.get("behavior_pattern", "")
            pattern2 = beh2.get("behavior_pattern", "")
            
            if pattern1 == pattern2:
                score += 1
            factors += 1
        
        # –°—Ö–æ–∂—ñ—Å—Ç—å –∫–æ–Ω—Ç–µ–Ω—Ç—É
        cont1 = profile1.get("content", {})
        cont2 = profile2.get("content", {})
        
        if cont1 and cont2:
            topics1 = set(cont1.get("topics", []))
            topics2 = set(cont2.get("topics", []))
            
            if topics1 and topics2:
                overlap = len(topics1.intersection(topics2))
                union = len(topics1.union(topics2))
                if union > 0:
                    score += overlap / union
                    factors += 1
        
        if factors == 0:
            return 0
        
        return round(score / factors, 3)
    
    def _cluster_profiles(self, profiles: List[Dict]) -> List[Dict]:
        """–ö–ª–∞—Å—Ç–µ—Ä–∏–∑—É—î –ø—Ä–æ—Ñ—ñ–ª—ñ –∑–∞ —Å—Ö–æ–∂—ñ—Å—Ç—é"""
        # –°–ø—Ä–æ—â–µ–Ω–∞ —Ä–µ–∞–ª—ñ–∑–∞—Ü—ñ—è - –º–æ–∂–Ω–∞ –∑–∞–º—ñ–Ω–∏—Ç–∏ –Ω–∞ DBSCAN —á–∏ k-means
        if len(profiles) < 2:
            return []
        
        # –ì—Ä—É–ø—É—î–º–æ –∑–∞ —Ç–∏–ø–æ–º –ø–æ–≤–µ–¥—ñ–Ω–∫–∏
        clusters = {}
        for i, profile in enumerate(profiles):
            behavior = profile.get("behavior", {}).get("behavior_pattern", "unknown")
            
            if behavior not in clusters:
                clusters[behavior] = []
            
            clusters[behavior].append({
                "profile_index": i,
                "user_id": profile.get("id"),
                "username": profile.get("username")
            })
        
        # –§–æ—Ä–º–∞—Ç—É—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏
        result = []
        for behavior_type, members in clusters.items():
            result.append({
                "cluster_type": behavior_type,
                "member_count": len(members),
                "members": members[:10]  # –û–±–º–µ–∂—É—î–º–æ —Å–ø–∏—Å–æ–∫
            })
        
        return result
    
    async def get_user_profile(self, user_id: str) -> Optional[Dict]:
        """–û—Ç—Ä–∏–º—É—î –∑–∞–∫–µ—à–æ–≤–∞–Ω–∏–π –ø—Ä–æ—Ñ—ñ–ª—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞"""
        cache_key = f"user_profile:{user_id}"
        
        if cache_key in self.user_profiles:
            cache_data = self.user_profiles[cache_key]
            
            # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ –Ω–µ –ø—Ä–æ—Å—Ç—Ä–æ—á–µ–Ω–∏–π (1 –¥–µ–Ω—å)
            cache_age = datetime.now().timestamp() - cache_data["timestamp"]
            if cache_age < 86400:  # 24 –≥–æ–¥–∏–Ω–∏
                return cache_data["data"]
        
        return None
    
    async def track_user_activity(self, user_id: str, bot_id: str,
                                 chat_id: str, duration_hours: int = 24) -> str:
        """
        –í—ñ–¥—Å—Ç–µ–∂—É—î –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ –≤ —Ä–µ–∞–ª—å–Ω–æ–º—É —á–∞—Å—ñ
        
        Returns:
            ID –∑–∞–¥–∞—á—ñ –≤—ñ–¥—Å—Ç–µ–∂–µ–Ω–Ω—è
        """
        task_id = f"track_{user_id}_{int(datetime.now().timestamp())}"
        
        # –ó–∞–ø—É—Å–∫–∞—î–º–æ –≤—ñ–¥—Å—Ç–µ–∂–µ–Ω–Ω—è –≤ –æ–∫—Ä–µ–º–æ–º—É –ø–æ—Ç–æ—Ü—ñ
        task = asyncio.create_task(
            self._run_tracking(user_id, bot_id, chat_id, duration_hours, task_id)
        )
        
        self.behavior_patterns[task_id] = {
            'task': task,
            'user_id': user_id,
            'chat_id': chat_id,
            'started_at': datetime.now().isoformat(),
            'status': 'running'
        }
        
        return task_id
    
    async def _run_tracking(self, user_id: str, bot_id: str,
                           chat_id: str, duration_hours: int, task_id: str):
        """–ó–∞–ø—É—Å–∫–∞—î –≤—ñ–¥—Å—Ç–µ–∂–µ–Ω–Ω—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ"""
        try:
            if bot_id not in bot_manager.bots:
                logger.error(f"Bot {bot_id} not found for tracking")
                return
            
            client = bot_manager.bots[bot_id]
            entity = await client.get_entity(chat_id)
            
            # –û—Ç—Ä–∏–º—É—î–º–æ –æ—Å—Ç–∞–Ω–Ω—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞ —è–∫ —Ç–æ—á–∫—É –≤—ñ–¥–ª—ñ–∫—É
            last_message_id = None
            async for message in client.iter_messages(
                entity,
                from_user=user_id,
                limit=1
            ):
                last_message_id = message.id
                break
            
            logger.info(f"Starting tracking for user {user_id} in chat {chat_id}")
            
            end_time = datetime.now().timestamp() + (duration_hours * 3600)
            activity_log = []
            
            # –û—Å–Ω–æ–≤–Ω–∏–π —Ü–∏–∫–ª –≤—ñ–¥—Å—Ç–µ–∂–µ–Ω–Ω—è
            while (datetime.now().timestamp() < end_time and 
                   task_id in self.behavior_patterns):
                try:
                    # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –Ω–æ–≤—ñ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
                    new_messages = []
                    
                    async for message in client.iter_messages(
                        entity,
                        from_user=user_id,
                        min_id=last_message_id,
                        limit=50
                    ):
                        if message.id > (last_message_id or 0):
                            activity_log.append({
                                "timestamp": datetime.now().isoformat(),
                                "message_id": message.id,
                                "text_length": len(message.text or ""),
                                "has_media": bool(message.media)
                            })
                            
                            last_message_id = max(
                                last_message_id or 0, 
                                message.id
                            )
                    
                    # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ –∞–∫—Ç–∏–≤–Ω—ñ—Å—Ç—å –∫–æ–∂–Ω—ñ 10 —Ö–≤–∏–ª–∏–Ω
                    if len(activity_log) >= 5:
                        pattern = self._detect_activity_pattern(activity_log[-20:])
                        
                        # –û–Ω–æ–≤–ª—é—î–º–æ —à–∞–±–ª–æ–Ω –ø–æ–≤–µ–¥—ñ–Ω–∫–∏
                        if task_id in self.behavior_patterns:
                            self.behavior_patterns[task_id]['current_pattern'] = pattern
                    
                    # –ß–µ–∫–∞—î–º–æ –ø–µ—Ä–µ–¥ –Ω–∞—Å—Ç—É–ø–Ω–æ—é –ø–µ—Ä–µ–≤—ñ—Ä–∫–æ—é
                    await asyncio.sleep(60)  # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –∫–æ–∂–Ω—É —Ö–≤–∏–ª–∏–Ω—É
                    
                except Exception as e:
                    logger.error(f"Tracking iteration failed: {e}")
                    await asyncio.sleep(30)
            
            # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ –≤—ñ–¥—Å—Ç–µ–∂–µ–Ω–Ω—è
            if activity_log:
                await self._save_tracking_results(
                    user_id, chat_id, activity_log, task_id
                )
            
        except Exception as e:
            logger.error(f"Tracking task failed: {e}")
        finally:
            # –ü—Ä–∏–±–∏—Ä–∞—î–º–æ –∑–∞–¥–∞—á—É –∑ –∞–∫—Ç–∏–≤–Ω–∏—Ö
            if task_id in self.behavior_patterns:
                del self.behavior_patterns[task_id]
    
    def _detect_activity_pattern(self, activity_log: List[Dict]) -> str:
        """–í–∏–∑–Ω–∞—á–∞—î —à–∞–±–ª–æ–Ω –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ –Ω–∞ –æ—Å–Ω–æ–≤—ñ –ª–æ–≥—É"""
        if len(activity_log) < 5:
            return "insufficient_data"
        
        # –ê–Ω–∞–ª—ñ–∑—É—î–º–æ —á–∞—Å–æ–≤—ñ –ø—Ä–æ–º—ñ–∂–∫–∏
        timestamps = [
            datetime.fromisoformat(entry["timestamp"]).timestamp()
            for entry in activity_log
        ]
        
        if len(timestamps) < 2:
            return "unknown"
        
        gaps = [timestamps[i] - timestamps[i-1] for i in range(1, len(timestamps))]
        
        avg_gap = sum(gaps) / len(gaps)
        
        if avg_gap < 300:  # < 5 —Ö–≤–∏–ª–∏–Ω
            return "burst_activity"
        elif avg_gap < 1800:  # < 30 —Ö–≤–∏–ª–∏–Ω
            return "frequent_activity"
        elif avg_gap < 7200:  # < 2 –≥–æ–¥–∏–Ω–∏
            return "regular_activity"
        else:
            return "sporadic_activity"
    
    async def _save_tracking_results(self, user_id: str, chat_id: str,
                                    activity_log: List[Dict], task_id: str):
        """–ó–±–µ—Ä—ñ–≥–∞—î —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏ –≤—ñ–¥—Å—Ç–µ–∂–µ–Ω–Ω—è"""
        from database.crud import create_tracking_result
        
        tracking_data = {
            "user_id": user_id,
            "chat_id": chat_id,
            "task_id": task_id,
            "activity_log": activity_log,
            "total_activities": len(activity_log),
            "tracking_duration": self._calculate_tracking_duration(activity_log),
            "detected_pattern": self._detect_activity_pattern(activity_log),
            "completed_at": datetime.now().isoformat()
        }
        
        await create_tracking_result(tracking_data)
    
    def _calculate_tracking_duration(self, activity_log: List[Dict]) -> int:
        """–†–æ–∑—Ä–∞—Ö–æ–≤—É—î —Ç—Ä–∏–≤–∞–ª—ñ—Å—Ç—å –≤—ñ–¥—Å—Ç–µ–∂–µ–Ω–Ω—è –≤ —Å–µ–∫—É–Ω–¥–∞—Ö"""
        if len(activity_log) < 2:
            return 0
        
        first_time = datetime.fromisoformat(activity_log[0]["timestamp"])
        last_time = datetime.fromisoformat(activity_log[-1]["timestamp"])
        
        return int((last_time - first_time).total_seconds())
    
    async def stop_tracking(self, task_id: str) -> bool:
        """–ó—É–ø–∏–Ω—è—î –≤—ñ–¥—Å—Ç–µ–∂–µ–Ω–Ω—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ"""
        if task_id in self.behavior_patterns:
            task_info = self.behavior_patterns[task_id]
            task_info['task'].cancel()
            del self.behavior_patterns[task_id]
            return True
        return False
    
    async def get_tracking_status(self, task_id: str) -> Optional[Dict]:
        """–û—Ç—Ä–∏–º—É—î —Å—Ç–∞—Ç—É—Å –≤—ñ–¥—Å—Ç–µ–∂–µ–Ω–Ω—è"""
        if task_id in self.behavior_patterns:
            task_info = self.behavior_patterns[task_id].copy()
            # –í–∏–¥–∞–ª—è—î–º–æ –æ–±'—î–∫—Ç –∑–∞–¥–∞—á—ñ (–Ω–µ —Å–µ—Ä—ñ–∞–ª—ñ–∑—É—î—Ç—å—Å—è)
            if 'task' in task_info:
                del task_info['task']
            return task_info
        return None

user_analyzer = UserAnalyzer()
```

üì® 4. –ú–û–î–£–õ–¨ –†–û–ó–°–ò–õ–û–ö (modules/messaging/)

modules/messaging/campaign_manager.py

```python
import asyncio
import logging
from typing import List, Dict, Optional
from datetime import datetime, timedelta
import random
from enum import Enum
from config.settings import settings
from core.bot_manager import bot_manager
from database.crud import create_campaign, update_campaign

logger = logging.getLogger(__name__)

class CampaignStatus(Enum):
    DRAFT = "draft"
    SCHEDULED = "scheduled"
    RUNNING = "running"
    PAUSED = "paused"
    COMPLETED = "completed"
    CANCELLED = "cancelled"
    FAILED = "failed"

class MessageType(Enum):
    TEXT = "text"
    PHOTO = "photo"
    VIDEO = "video"
    DOCUMENT = "document"
    POLL = "poll"

class CampaignManager:
    def __init__(self):
        self.active_campaigns = {}
        self.campaign_queue = asyncio.Queue()
        self.rate_limiter = RateLimiter()
        
    async def create_campaign(self, campaign_data: Dict) -> Dict:
        """
        –°—Ç–≤–æ—Ä—é—î –Ω–æ–≤—É –∫–∞–º–ø–∞–Ω—ñ—é —Ä–æ–∑—Å–∏–ª–∫–∏
        
        Args:
            campaign_data: –î–∞–Ω—ñ –∫–∞–º–ø–∞–Ω—ñ—ó
            
        Returns:
            Dict –∑ ID —Ç–∞ —Å—Ç–∞—Ç—É—Å–æ–º –∫–∞–º–ø–∞–Ω—ñ—ó
        """
        try:
            # –í–∞–ª—ñ–¥—É—î–º–æ –¥–∞–Ω—ñ
            validation_result = await self._validate_campaign_data(campaign_data)
            if not validation_result["valid"]:
                return {"error": validation_result["errors"]}
            
            # –ì–µ–Ω–µ—Ä—É—î–º–æ ID –∫–∞–º–ø–∞–Ω—ñ—ó
            campaign_id = f"camp_{int(datetime.now().timestamp())}"
            
            # –û–±—Ä–æ–±–ª—è—î–º–æ –æ–¥–µ—Ä–∂—É–≤–∞—á—ñ–≤
            recipients = await self._process_recipients(
                campaign_data["recipients"]
            )
            
            # –û–±—Ä–æ–±–ª—è—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
            messages = await self._process_messages(campaign_data["messages"])
            
            # –†–æ–∑—Ä–∞—Ö–æ–≤—É—î–º–æ –≥—Ä–∞—Ñ—ñ–∫
            schedule = await self._calculate_schedule(
                campaign_data.get("schedule", {}),
                len(recipients),
                len(messages)
            )
            
            # –°—Ç–≤–æ—Ä—é—î–º–æ –æ–±'—î–∫—Ç –∫–∞–º–ø–∞–Ω—ñ—ó
            campaign = {
                "id": campaign_id,
                "name": campaign_data.get("name", f"Campaign {campaign_id}"),
                "creator_id": campaign_data["creator_id"],
                "project_id": campaign_data.get("project_id"),
                "status": CampaignStatus.DRAFT.value,
                "recipients": recipients,
                "messages": messages,
                "schedule": schedule,
                "settings": campaign_data.get("settings", {}),
                "created_at": datetime.now().isoformat(),
                "stats": {
                    "total_recipients": len(recipients),
                    "total_messages": len(messages),
                    "sent": 0,
                    "delivered": 0,
                    "failed": 0,
                    "started_at": None,
                    "completed_at": None
                }
            }
            
            # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –≤ –±–∞–∑—É –¥–∞–Ω–∏—Ö
            await create_campaign(campaign)
            
            # –î–æ–¥–∞—î–º–æ –≤ —á–µ—Ä–≥—É, —è–∫—â–æ —Ç—Ä–µ–±–∞ –∑–∞–ø—É—Å—Ç–∏—Ç–∏ –≤—ñ–¥—Ä–∞–∑—É
            if campaign_data.get("start_immediately", False):
                campaign["status"] = CampaignStatus.SCHEDULED.value
                await self.campaign_queue.put(campaign_id)
                await update_campaign(campaign_id, {"status": CampaignStatus.SCHEDULED.value})
            
            logger.info(f"Campaign {campaign_id} created successfully")
            return {"campaign_id": campaign_id, "status": campaign["status"]}
            
        except Exception as e:
            logger.error(f"Failed to create campaign: {e}")
            return {"error": str(e)}
    
    async def _validate_campaign_data(self, data: Dict) -> Dict:
        """–í–∞–ª—ñ–¥—É—î –¥–∞–Ω—ñ –∫–∞–º–ø–∞–Ω—ñ—ó"""
        errors = []
        
        # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –æ–±–æ–≤'—è–∑–∫–æ–≤—ñ –ø–æ–ª—è
        required_fields = ["creator_id", "recipients", "messages"]
        for field in required_fields:
            if field not in data or not data[field]:
                errors.append(f"Missing required field: {field}")
        
        # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –æ–¥–µ—Ä–∂—É–≤–∞—á—ñ–≤
        if "recipients" in data:
            if isinstance(data["recipients"], list):
                if len(data["recipients"]) == 0:
                    errors.append("Recipients list is empty")
                elif len(data["recipients"]) > 10000:
                    errors.append("Too many recipients (max 10000)")
            else:
                errors.append("Recipients must be a list")
        
        # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
        if "messages" in data:
            if not isinstance(data["messages"], list):
                errors.append("Messages must be a list")
            elif len(data["messages"]) == 0:
                errors.append("Messages list is empty")
            else:
                for i, msg in enumerate(data["messages"]):
                    if not isinstance(msg, dict):
                        errors.append(f"Message {i} must be a dictionary")
                    elif "content" not in msg:
                        errors.append(f"Message {i} missing content")
        
        return {"valid": len(errors) == 0, "errors": errors}
    
    async def _process_recipients(self, recipients: List) -> List[Dict]:
        """–û–±—Ä–æ–±–ª—è—î —Å–ø–∏—Å–æ–∫ –æ–¥–µ—Ä–∂—É–≤–∞—á—ñ–≤"""
        processed = []
        
        for recipient in recipients:
            if isinstance(recipient, dict):
                # –í–∂–µ –æ–±—Ä–æ–±–ª–µ–Ω–∏–π
                processed.append(recipient)
            elif isinstance(recipient, str):
                # –û–±—Ä–æ–±–ª—è—î–º–æ —Ä—è–¥–æ–∫
                if recipient.startswith("@"):
                    processed.append({"type": "username", "value": recipient})
                elif recipient.isdigit():
                    processed.append({"type": "user_id", "value": int(recipient)})
                else:
                    # –°–ø—Ä–æ–±–∞ —è–∫ –ø–æ—Å–∏–ª–∞–Ω–Ω—è –Ω–∞ —á–∞—Ç
                    processed.append({"type": "chat_link", "value": recipient})
            else:
                logger.warning(f"Invalid recipient format: {recipient}")
        
        return processed
    
    async def _process_messages(self, messages: List[Dict]) -> List[Dict]:
        """–û–±—Ä–æ–±–ª—è—î –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –∫–∞–º–ø–∞–Ω—ñ—ó"""
        processed = []
        
        for i, msg in enumerate(messages):
            message_id = f"msg_{i}_{int(datetime.now().timestamp())}"
            
            processed_msg = {
                "id": message_id,
                "content": msg["content"],
                "type": msg.get("type", MessageType.TEXT.value),
                "media_path": msg.get("media_path"),
                "buttons": msg.get("buttons", []),
                "settings": {
                    "parse_mode": msg.get("parse_mode", "HTML"),
                    "disable_web_page_preview": msg.get("disable_web_page_preview", False),
                    "disable_notification": msg.get("disable_notification", False)
                }
            }
            
            # –Ø–∫—â–æ —î AI –≥–µ–Ω–µ—Ä–∞—Ü—ñ—è
            if msg.get("generate_with_ai", False):
                processed_msg["content"] = await self._generate_with_ai(
                    msg["content"],
                    msg.get("ai_prompt", "")
                )
            
            processed.append(processed_msg)
        
        return processed
    
    async def _generate_with_ai(self, template: str, prompt: str) -> str:
        """–ì–µ–Ω–µ—Ä—É—î –∫–æ–Ω—Ç–µ–Ω—Ç –∑–∞ –¥–æ–ø–æ–º–æ–≥–æ—é AI"""
        # –¢—É—Ç –±—É–¥–µ —ñ–Ω—Ç–µ–≥—Ä–∞—Ü—ñ—è –∑ OpenAI/Gemini
        # –ü–æ–∫–∏ –ø–æ–≤–µ—Ä—Ç–∞—î–º–æ —à–∞–±–ª–æ–Ω
        return template
    
    async def _calculate_schedule(self, schedule_data: Dict,
                                 recipient_count: int,
                                 message_count: int) -> Dict:
        """–†–æ–∑—Ä–∞—Ö–æ–≤—É—î –≥—Ä–∞—Ñ—ñ–∫ —Ä–æ–∑—Å–∏–ª–∫–∏"""
        default_schedule = {
            "start_time": datetime.now().isoformat(),
            "end_time": (datetime.now() + timedelta(days=1)).isoformat(),
            "timezone": "UTC",
            "working_hours": {"start": 9, "end": 21},  # 9:00 - 21:00
            "messages_per_hour": 20,
            "delay_between_messages": {"min": 30, "max": 300},  # 30-300 —Å–µ–∫—É–Ω–¥
            "delay_between_recipients": {"min": 10, "max": 60}  # 10-60 —Å–µ–∫—É–Ω–¥
        }
        
        # –ú–µ—Ä–¥–∂–∏–º–æ –∑ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è–º–∏ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞
        schedule = {**default_schedule, **schedule_data}
        
        # –†–æ–∑—Ä–∞—Ö–æ–≤—É—î–º–æ –∑–∞–≥–∞–ª—å–Ω–∏–π —á–∞—Å
        total_messages = recipient_count * message_count
        messages_per_hour = schedule["messages_per_hour"]
        
        if messages_per_hour > 0:
            estimated_hours = total_messages / messages_per_hour
            schedule["estimated_duration_hours"] = round(estimated_hours, 2)
        
        return schedule
    
    async def start_campaign(self, campaign_id: str) -> Dict:
        """–ó–∞–ø—É—Å–∫–∞—î –∫–∞–º–ø–∞–Ω—ñ—é"""
        try:
            # –û—Ç—Ä–∏–º—É—î–º–æ –∫–∞–º–ø–∞–Ω—ñ—é –∑ –±–∞–∑–∏ –¥–∞–Ω–∏—Ö
            from database.crud import get_campaign
            
            campaign = await get_campaign(campaign_id)
            if not campaign:
                return {"error": "Campaign not found"}
            
            # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —Å—Ç–∞—Ç—É—Å
            if campaign["status"] not in [CampaignStatus.DRAFT.value, 
                                         CampaignStatus.PAUSED.value]:
                return {"error": f"Cannot start campaign with status: {campaign['status']}"}
            
            # –û–Ω–æ–≤–ª—é—î–º–æ —Å—Ç–∞—Ç—É—Å
            campaign["status"] = CampaignStatus.RUNNING.value
            campaign["stats"]["started_at"] = datetime.now().isoformat()
            
            await update_campaign(campaign_id, {
                "status": CampaignStatus.RUNNING.value,
                "stats": campaign["stats"]
            })
            
            # –ó–∞–ø—É—Å–∫–∞—î–º–æ –∫–∞–º–ø–∞–Ω—ñ—é –≤ –æ–∫—Ä–µ–º–æ–º—É –ø–æ—Ç–æ—Ü—ñ
            task = asyncio.create_task(
                self._run_campaign(campaign_id, campaign)
            )
            
            self.active_campaigns[campaign_id] = {
                "task": task,
                "campaign": campaign,
                "started_at": datetime.now().isoformat()
            }
            
            logger.info(f"Campaign {campaign_id} started")
            return {"status": "started", "campaign_id": campaign_id}
            
        except Exception as e:
            logger.error(f"Failed to start campaign: {e}")
            return {"error": str(e)}
    
    async def _run_campaign(self, campaign_id: str, campaign: Dict):
        """–í–∏–∫–æ–Ω—É—î –∫–∞–º–ø–∞–Ω—ñ—é"""
        try:
            logger.info(f"Running campaign {campaign_id}")
            
            # –û—Ç—Ä–∏–º—É—î–º–æ –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –±–æ—Ç—ñ–≤
            available_bots = await self._get_available_bots(
                campaign.get("project_id")
            )
            
            if not available_bots:
                logger.error(f"No available bots for campaign {campaign_id}")
                await self._mark_campaign_failed(campaign_id, "No available bots")
                return
            
            # –†–æ–∑–ø–æ–¥—ñ–ª—è—î–º–æ –æ–¥–µ—Ä–∂—É–≤–∞—á—ñ–≤ –º—ñ–∂ –±–æ—Ç–∞–º–∏
            bot_assignments = self._distribute_recipients(
                campaign["recipients"],
                available_bots
            )
            
            # –ó–∞–ø—É—Å–∫–∞—î–º–æ –≤—ñ–¥–ø—Ä–∞–≤–∫—É –¥–ª—è –∫–æ–∂–Ω–æ–≥–æ –±–æ—Ç–∞
            tasks = []
            for bot_id, recipients in bot_assignments.items():
                task = asyncio.create_task(
                    self._send_batch(bot_id, recipients, campaign)
                )
                tasks.append(task)
            
            # –ß–µ–∫–∞—î–º–æ –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—è –≤—Å—ñ—Ö –∑–∞–¥–∞—á
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            # –û–±—Ä–æ–±–ª—è—î–º–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏
            success_count = sum(1 for r in results if not isinstance(r, Exception))
            fail_count = len(results) - success_count
            
            # –û–Ω–æ–≤–ª—é—î–º–æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            campaign["stats"]["sent"] = sum(
                len(recipients) for recipients in bot_assignments.values()
            )
            campaign["stats"]["failed"] = fail_count
            campaign["stats"]["completed_at"] = datetime.now().isoformat()
            
            if fail_count == 0:
                campaign["status"] = CampaignStatus.COMPLETED.value
            else:
                campaign["status"] = CampaignStatus.FAILED.value
            
            await update_campaign(campaign_id, {
                "status": campaign["status"],
                "stats": campaign["stats"]
            })
            
            logger.info(f"Campaign {campaign_id} completed")
            
        except Exception as e:
            logger.error(f"Campaign execution failed: {e}")
            await self._mark_campaign_failed(campaign_id, str(e))
        finally:
            # –í–∏–¥–∞–ª—è—î–º–æ –∑ –∞–∫—Ç–∏–≤–Ω–∏—Ö –∫–∞–º–ø–∞–Ω—ñ–π
            if campaign_id in self.active_campaigns:
                del self.active_campaigns[campaign_id]
    
    async def _get_available_bots(self, project_id: Optional[str]) -> List[str]:
        """–û—Ç—Ä–∏–º—É—î –¥–æ—Å—Ç—É–ø–Ω–∏—Ö –±–æ—Ç—ñ–≤ –¥–ª—è –∫–∞–º–ø–∞–Ω—ñ—ó"""
        available_bots = []
        
        for bot_id, client in bot_manager.bots.items():
            # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –ø—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è
            try:
                if await client.is_connected():
                    # –ú–æ–∂–Ω–∞ –¥–æ–¥–∞—Ç–∏ –¥–æ–¥–∞—Ç–∫–æ–≤—ñ –ø–µ—Ä–µ–≤—ñ—Ä–∫–∏ –∑–∞ –ø—Ä–æ–µ–∫—Ç–æ–º
                    available_bots.append(bot_id)
            except:
                continue
        
        return available_bots
    
    def _distribute_recipients(self, recipients: List[Dict], 
                              bots: List[str]) -> Dict[str, List[Dict]]:
        """–†–æ–∑–ø–æ–¥—ñ–ª—è—î –æ–¥–µ—Ä–∂—É–≤–∞—á—ñ–≤ –º—ñ–∂ –±–æ—Ç–∞–º–∏"""
        assignments = {bot_id: [] for bot_id in bots}
        
        for i, recipient in enumerate(recipients):
            bot_index = i % len(bots)
            bot_id = bots[bot_index]
            assignments[bot_id].append(recipient)
        
        return assignments
    
    async def _send_batch(self, bot_id: str, recipients: List[Dict], 
                         campaign: Dict):
        """–í—ñ–¥–ø—Ä–∞–≤–ª—è—î –ø–∞—Ä—Ç—ñ—é –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω—å –æ–¥–Ω–∏–º –±–æ—Ç–æ–º"""
        try:
            if bot_id not in bot_manager.bots:
                raise Exception(f"Bot {bot_id} not found")
            
            client = bot_manager.bots[bot_id]
            sent_count = 0
            
            for recipient in recipients:
                try:
                    # –ó–∞—Å—Ç–æ—Å–æ–≤—É—î–º–æ –æ–±–º–µ–∂–µ–Ω–Ω—è —à–≤–∏–¥–∫–æ—Å—Ç—ñ
                    await self.rate_limiter.wait_for_bot(bot_id)
                    
                    # –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –∫–æ–∂–Ω–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è –∫–∞–º–ø–∞–Ω—ñ—ó
                    for message in campaign["messages"]:
                        # –ó–∞—Ç—Ä–∏–º–∫–∞ –º—ñ–∂ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è–º–∏ –æ–¥–Ω–æ–º—É –æ–¥–µ—Ä–∂—É–≤–∞—á—É
                        delay = random.randint(
                            campaign["schedule"]["delay_between_messages"]["min"],
                            campaign["schedule"]["delay_between_messages"]["max"]
                        )
                        await asyncio.sleep(delay)
                        
                        # –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
                        result = await self._send_message(
                            client, recipient, message
                        )
                        
                        if result["success"]:
                            sent_count += 1
                            await self._log_delivery(
                                campaign["id"], bot_id, recipient, 
                                message["id"], True
                            )
                        else:
                            await self._log_delivery(
                                campaign["id"], bot_id, recipient,
                                message["id"], False, result.get("error")
                            )
                    
                    # –ó–∞—Ç—Ä–∏–º–∫–∞ –º—ñ–∂ –æ–¥–µ—Ä–∂—É–≤–∞—á–∞–º–∏
                    delay = random.randint(
                        campaign["schedule"]["delay_between_recipients"]["min"],
                        campaign["schedule"]["delay_between_recipients"]["max"]
                    )
                    await asyncio.sleep(delay)
                    
                except Exception as e:
                    logger.error(f"Failed to send to {recipient}: {e}")
                    await self._log_delivery(
                        campaign["id"], bot_id, recipient,
                        "all", False, str(e)
                    )
                    continue
            
            return {"bot_id": bot_id, "sent": sent_count}
            
        except Exception as e:
            logger.error(f"Batch sending failed for bot {bot_id}: {e}")
            raise
    
    async def _send_message(self, client, recipient: Dict, 
                           message: Dict) -> Dict:
        """–í—ñ–¥–ø—Ä–∞–≤–ª—è—î –æ–¥–Ω–µ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è"""
        try:
            # –û—Ç—Ä–∏–º—É—î–º–æ —Å—É—Ç–Ω—ñ—Å—Ç—å –æ–¥–µ—Ä–∂—É–≤–∞—á–∞
            entity = await self._get_recipient_entity(client, recipient)
            if not entity:
                return {"success": False, "error": "Failed to get entity"}
            
            # –ü—ñ–¥–≥–æ—Ç–æ–≤–ª—é—î–º–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
            send_kwargs = {
                "entity": entity,
                "message": message["content"],
                "parse_mode": message["settings"]["parse_mode"],
                "link_preview": not message["settings"]["disable_web_page_preview"],
                "silent": message["settings"]["disable_notification"]
            }
            
            # –î–æ–¥–∞—î–º–æ –º–µ–¥—ñ–∞, —è–∫—â–æ —î
            if message.get("media_path"):
                # –¢—É—Ç –±—É–¥–µ –∑–∞–≤–∞–Ω—Ç–∞–∂–µ–Ω–Ω—è —Ç–∞ –≤—ñ–¥–ø—Ä–∞–≤–∫–∞ –º–µ–¥—ñ–∞
                pass
            
            # –í—ñ–¥–ø—Ä–∞–≤–ª—è—î–º–æ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è
            sent_message = await client.send_message(**send_kwargs)
            
            return {"success": True, "message_id": sent_message.id}
            
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def _get_recipient_entity(self, client, recipient: Dict):
        """–û—Ç—Ä–∏–º—É—î —Å—É—Ç–Ω—ñ—Å—Ç—å –æ–¥–µ—Ä–∂—É–≤–∞—á–∞"""
        try:
            if recipient["type"] == "username":
                return await client.get_entity(recipient["value"])
            elif recipient["type"] == "user_id":
                return await client.get_entity(recipient["value"])
            elif recipient["type"] == "chat_link":
                # –û–±—Ä–æ–±–ª—è—î–º–æ –ø–æ—Å–∏–ª–∞–Ω–Ω—è –Ω–∞ —á–∞—Ç
                # –ú–æ–∂–Ω–∞ –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É–≤–∞—Ç–∏ client.get_entity() –∑ –ø–æ—Å–∏–ª–∞–Ω–Ω—è–º
                return await client.get_entity(recipient["value"])
            else:
                return None
        except:
            return None
    
    async def _log_delivery(self, campaign_id: str, bot_id: str,
                           recipient: Dict, message_id: str,
                           success: bool, error: str = None):
        """–õ–æ–≥—É—î –¥–æ—Å—Ç–∞–≤–∫—É –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è"""
        from database.crud import create_delivery_log
        
        log_data = {
            "campaign_id": campaign_id,
            "bot_id": bot_id,
            "recipient_type": recipient["type"],
            "recipient_value": recipient["value"],
            "message_id": message_id,
            "success": success,
            "error": error,
            "sent_at": datetime.now().isoformat()
        }
        
        await create_delivery_log(log_data)
    
    async def _mark_campaign_failed(self, campaign_id: str, error: str):
        """–ü–æ–∑–Ω–∞—á–∞—î –∫–∞–º–ø–∞–Ω—ñ—é —è–∫ –Ω–µ–≤–¥–∞–ª—É"""
        try:
            await update_campaign(campaign_id, {
                "status": CampaignStatus.FAILED.value,
                "error": error,
                "completed_at": datetime.now().isoformat()
            })
        except Exception as e:
            logger.error(f"Failed to mark campaign as failed: {e}")
    
    async def pause_campaign(self, campaign_id: str) -> Dict:
        """–ü—Ä–∏–∑—É–ø–∏–Ω—è—î –∫–∞–º–ø–∞–Ω—ñ—é"""
        try:
            if campaign_id in self.active_campaigns:
                # –ü—Ä–∏–∑—É–ø–∏–Ω—è—î–º–æ –∑–∞–¥–∞—á—É
                self.active_campaigns[campaign_id]["task"].cancel()
                
                # –û–Ω–æ–≤–ª—é—î–º–æ —Å—Ç–∞—Ç—É—Å
                await update_campaign(campaign_id, {
                    "status": CampaignStatus.PAUSED.value
                })
                
                # –í–∏–¥–∞–ª—è—î–º–æ –∑ –∞–∫—Ç–∏–≤–Ω–∏—Ö
                del self.active_campaigns[campaign_id]
                
                return {"status": "paused", "campaign_id": campaign_id}
            else:
                # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –≤ –±–∞–∑—ñ –¥–∞–Ω–∏—Ö
                from database.crud import get_campaign, update_campaign
                campaign = await get_campaign(campaign_id)
                
                if not campaign:
                    return {"error": "Campaign not found"}
                
                if campaign["status"] == CampaignStatus.RUNNING.value:
                    await update_campaign(campaign_id, {
                        "status": CampaignStatus.PAUSED.value
                    })
                    return {"status": "paused", "campaign_id": campaign_id}
                else:
                    return {"error": f"Cannot pause campaign with status: {campaign['status']}"}
                    
        except Exception as e:
            logger.error(f"Failed to pause campaign: {e}")
            return {"error": str(e)}
    
    async def resume_campaign(self, campaign_id: str) -> Dict:
        """–í—ñ–¥–Ω–æ–≤–ª—é—î –ø—Ä–∏–∑—É–ø–∏–Ω–µ–Ω—É –∫–∞–º–ø–∞–Ω—ñ—é"""
        try:
            from database.crud import get_campaign
            
            campaign = await get_campaign(campaign_id)
            if not campaign:
                return {"error": "Campaign not found"}
            
            if campaign["status"] != CampaignStatus.PAUSED.value:
                return {"error": f"Cannot resume campaign with status: {campaign['status']}"}
            
            # –ó–∞–ø—É—Å–∫–∞—î–º–æ –∑–Ω–æ–≤—É
            return await self.start_campaign(campaign_id)
            
        except Exception as e:
            logger.error(f"Failed to resume campaign: {e}")
            return {"error": str(e)}
    
    async def cancel_campaign(self, campaign_id: str) -> Dict:
        """–°–∫–∞—Å–æ–≤—É—î –∫–∞–º–ø–∞–Ω—ñ—é"""
        try:
            # –°–∫–∞—Å–æ–≤—É—î–º–æ –∞–∫—Ç–∏–≤–Ω—É –∫–∞–º–ø–∞–Ω—ñ—é
            if campaign_id in self.active_campaigns:
                self.active_campaigns[campaign_id]["task"].cancel()
                del self.active_campaigns[campaign_id]
            
            # –û–Ω–æ–≤–ª—é—î–º–æ —Å—Ç–∞—Ç—É—Å –≤ –±–∞–∑—ñ –¥–∞–Ω–∏—Ö
            await update_campaign(campaign_id, {
                "status": CampaignStatus.CANCELLED.value,
                "cancelled_at": datetime.now().isoformat()
            })
            
            return {"status": "cancelled", "campaign_id": campaign_id}
            
        except Exception as e:
            logger.error(f"Failed to cancel campaign: {e}")
            return {"error": str(e)}
    
    async def get_campaign_stats(self, campaign_id: str) -> Dict:
        """–û—Ç—Ä–∏–º—É—î —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∫–∞–º–ø–∞–Ω—ñ—ó"""
        try:
            from database.crud import get_campaign, get_delivery_stats
            
            campaign = await get_campaign(campaign_id)
            if not campaign:
                return {"error": "Campaign not found"}
            
            # –û—Ç—Ä–∏–º—É—î–º–æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –¥–æ—Å—Ç–∞–≤–∫–∏
            delivery_stats = await get_delivery_stats(campaign_id)
            
            # –û–±'—î–¥–Ω—É—î–º–æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            stats = campaign.get("stats", {})
            stats.update(delivery_stats)
            
            # –î–æ–¥–∞—î–º–æ –ø—Ä–æ–≥—Ä–µ—Å
            if stats.get("total_recipients", 0) > 0:
                stats["progress_percentage"] = round(
                    stats.get("sent", 0) / stats["total_recipients"] * 100, 2
                )
            
            return {
                "campaign_id": campaign_id,
                "status": campaign["status"],
                "stats": stats,
                "schedule": campaign.get("schedule", {}),
                "settings": campaign.get("settings", {})
            }
            
        except Exception as e:
            logger.error(f"Failed to get campaign stats: {e}")
            return {"error": str(e)}
    
    async def list_campaigns(self, project_id: Optional[str] = None,
                            status: Optional[str] = None,
                            limit: int = 50,
                            offset: int = 0) -> Dict:
        """–û—Ç—Ä–∏–º—É—î —Å–ø–∏—Å–æ–∫ –∫–∞–º–ø–∞–Ω—ñ–π"""
        try:
            from database.crud import list_campaigns
            
            filters = {}
            if project_id:
                filters["project_id"] = project_id
            if status:
                filters["status"] = status
            
            campaigns = await list_campaigns(filters, limit, offset)
            
            # –î–æ–¥–∞—î–º–æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –¥–ª—è –∞–∫—Ç–∏–≤–Ω–∏—Ö –∫–∞–º–ø–∞–Ω—ñ–π
            for campaign in campaigns:
                if campaign["id"] in self.active_campaigns:
                    # –û–Ω–æ–≤–ª—é—î–º–æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∑ –∞–∫—Ç–∏–≤–Ω–∏—Ö –∫–∞–º–ø–∞–Ω—ñ–π
                    pass
            
            return {
                "campaigns": campaigns,
                "total": len(campaigns),
                "limit": limit,
                "offset": offset
            }
            
        except Exception as e:
            logger.error(f"Failed to list campaigns: {e}")
            return {"error": str(e)}
    
    async def duplicate_campaign(self, campaign_id: str, 
                                new_name: str = None) -> Dict:
        """–î—É–±–ª—ñ–∫—É—î –∫–∞–º–ø–∞–Ω—ñ—é"""
        try:
            from database.crud import get_campaign
            
            # –û—Ç—Ä–∏–º—É—î–º–æ –æ—Ä–∏–≥—ñ–Ω–∞–ª—å–Ω—É –∫–∞–º–ø–∞–Ω—ñ—é
            original = await get_campaign(campaign_id)
            if not original:
                return {"error": "Campaign not found"}
            
            # –°—Ç–≤–æ—Ä—é—î–º–æ –∫–æ–ø—ñ—é
            new_campaign = original.copy()
            
            # –ì–µ–Ω–µ—Ä—É—î–º–æ –Ω–æ–≤–∏–π ID
            new_campaign_id = f"camp_{int(datetime.now().timestamp())}"
            new_campaign["id"] = new_campaign_id
            
            # –û–Ω–æ–≤–ª—é—î–º–æ –Ω–∞–∑–≤—É
            if new_name:
                new_campaign["name"] = new_name
            else:
                new_campaign["name"] = f"{original['name']} (Copy)"
            
            # –°–∫–∏–¥–∞—î–º–æ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ç–∞ —Å—Ç–∞—Ç—É—Å
            new_campaign["status"] = CampaignStatus.DRAFT.value
            new_campaign["stats"] = {
                "total_recipients": len(new_campaign["recipients"]),
                "total_messages": len(new_campaign["messages"]),
                "sent": 0,
                "delivered": 0,
                "failed": 0,
                "started_at": None,
                "completed_at": None
            }
            new_campaign["created_at"] = datetime.now().isoformat()
            
            # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –Ω–æ–≤—É –∫–∞–º–ø–∞–Ω—ñ—é
            await create_campaign(new_campaign)
            
            logger.info(f"Campaign {campaign_id} duplicated as {new_campaign_id}")
            return {"new_campaign_id": new_campaign_id, "status": "duplicated"}
            
        except Exception as e:
            logger.error(f"Failed to duplicate campaign: {e}")
            return {"error": str(e)}

class RateLimiter:
    """–û–±–º–µ–∂—É–≤–∞—á —à–≤–∏–¥–∫–æ—Å—Ç—ñ –¥–ª—è –±–æ—Ç—ñ–≤"""
    
    def __init__(self):
        self.bot_limits = {}
        self.default_limit = {
            "messages_per_hour": 20,
            "messages_per_day": 200
        }
        self.bot_counters = {}
    
    async def wait_for_bot(self, bot_id: str):
        """–ß–µ–∫–∞—î, –ø–æ–∫–∏ –±–æ—Ç –º–æ–∂–µ –≤—ñ–¥–ø—Ä–∞–≤–∏—Ç–∏ –ø–æ–≤—ñ–¥–æ–º–ª–µ–Ω–Ω—è"""
        # –û—Ç—Ä–∏–º—É—î–º–æ –ª—ñ–º—ñ—Ç–∏ –¥–ª—è –±–æ—Ç–∞
        limits = self.bot_limits.get(bot_id, self.default_limit)
        
        # –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑—É—î–º–æ –ª—ñ—á–∏–ª—å–Ω–∏–∫, —è–∫—â–æ —Ç—Ä–µ–±–∞
        if bot_id not in self.bot_counters:
            self.bot_counters[bot_id] = {
                "hourly": 0,
                "daily": 0,
                "last_reset_hourly": datetime.now(),
                "last_reset_daily": datetime.now().date()
            }
        
        counter = self.bot_counters[bot_id]
        
        # –°–∫–∏–¥–∞—î–º–æ –ª—ñ—á–∏–ª—å–Ω–∏–∫–∏, —è–∫—â–æ —Ç—Ä–µ–±–∞
        self._reset_counters_if_needed(counter)
        
        # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –ª—ñ–º—ñ—Ç–∏
        if counter["hourly"] >= limits["messages_per_hour"]:
            # –ß–µ–∫–∞—î–º–æ –¥–æ –Ω–∞—Å—Ç—É–ø–Ω–æ—ó –≥–æ–¥–∏–Ω–∏
            wait_time = 3600 - (datetime.now() - counter["last_reset_hourly"]).seconds
            if wait_time > 0:
                await asyncio.sleep(wait_time)
                self._reset_counters_if_needed(counter)
        
        if counter["daily"] >= limits["messages_per_day"]:
            # –ß–µ–∫–∞—î–º–æ –¥–æ –Ω–∞—Å—Ç—É–ø–Ω–æ–≥–æ –¥–Ω—è
            tomorrow = datetime.now().date() + timedelta(days=1)
            wait_time = (datetime.combine(tomorrow, datetime.min.time()) - datetime.now()).seconds
            if wait_time > 0:
                await asyncio.sleep(wait_time)
                self._reset_counters_if_needed(counter)
        
        # –û–Ω–æ–≤–ª—é—î–º–æ –ª—ñ—á–∏–ª—å–Ω–∏–∫
        counter["hourly"] += 1
        counter["daily"] += 1
    
    def _reset_counters_if_needed(self, counter: Dict):
        """–°–∫–∏–¥–∞—î –ª—ñ—á–∏–ª—å–Ω–∏–∫–∏, —è–∫—â–æ –º–∏–Ω—É–≤ –ø–µ—Ä—ñ–æ–¥"""
        now = datetime.now()
        
        # –ì–æ–¥–∏–Ω–Ω–∏–π –ª—ñ—á–∏–ª—å–Ω–∏–∫
        if (now - counter["last_reset_hourly"]).seconds >= 3600:
            counter["hourly"] = 0
            counter["last_reset_hourly"] = now
        
        # –î–µ–Ω–Ω–∏–π –ª—ñ—á–∏–ª—å–Ω–∏–∫
        if now.date() > counter["last_reset_daily"]:
            counter["daily"] = 0
            counter["last_reset_daily"] = now.date()
    
    def set_bot_limits(self, bot_id: str, limits: Dict):
        """–í—Å—Ç–∞–Ω–æ–≤–ª—é—î –ª—ñ–º—ñ—Ç–∏ –¥–ª—è –±–æ—Ç–∞"""
        self.bot_limits[bot_id] = limits
    
    def get_bot_stats(self, bot_id: str) -> Dict:
        """–û—Ç—Ä–∏–º—É—î —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è –±–æ—Ç–∞"""
        if bot_id not in self.bot_counters:
            return {"error": "Bot not found"}
        
        counter = self.bot_counters[bot_id]
        limits = self.bot_limits.get(bot_id, self.default_limit)
        
        return {
            "hourly_used": counter["hourly"],
            "hourly_limit": limits["messages_per_hour"],
            "daily_used": counter["daily"],
            "daily_limit": limits["messages_per_day"],
            "hourly_percentage": round(counter["hourly"] / limits["messages_per_hour"] * 100, 2),
            "daily_percentage": round(counter["daily"] / limits["messages_per_day"] * 100, 2)
        }

campaign_manager = CampaignManager()
```

–¶–µ –ø—Ä–∞—Ü—é—é—á—ñ —Å–∫—Ä–∏–ø—Ç–∏ –¥–ª—è –æ—Å–Ω–æ–≤–Ω–æ–≥–æ —Ñ—É–Ω–∫—Ü—ñ–æ–Ω–∞–ª—É SHADOW SYSTEM iO. –ö–æ–∂–µ–Ω –º–æ–¥—É–ª—å —î –ø–æ–≤–Ω–æ—Ü—ñ–Ω–Ω–∏–º —ñ –≥–æ—Ç–æ–≤–∏–º –¥–æ –≤–∏–∫–æ—Ä–∏—Å—Ç–∞–Ω–Ω—è.

üöÄ –Ø–∫ –∑–∞–ø—É—Å—Ç–∏—Ç–∏:

1. –í—Å—Ç–∞–Ω–æ–≤—ñ—Ç—å –∑–∞–ª–µ–∂–Ω–æ—Å—Ç—ñ:

```bash
pip install telethon asyncpg redis aiohttp python-dotenv
```

1. –ù–∞–ª–∞—à—Ç—É–π—Ç–µ –∑–º—ñ–Ω–Ω—ñ —Å–µ—Ä–µ–¥–æ–≤–∏—â–∞ (.env —Ñ–∞–π–ª):

```env
API_ID=–≤–∞—à_api_id
API_HASH=–≤–∞—à_api_hash
BOT_TOKEN=–≤–∞—à_bot_token
POSTGRES_HOST=localhost
POSTGRES_PORT=5432
POSTGRES_DB=shadow_system
POSTGRES_USER=postgres
POSTGRES_PASSWORD=–ø–∞—Ä–æ–ª—å
```

1. –°—Ç–≤–æ—Ä—ñ—Ç—å –±–∞–∑—É –¥–∞–Ω–∏—Ö:

```sql
CREATE DATABASE shadow_system;
```

1. –ó–∞–ø—É—Å—Ç—ñ—Ç—å —Å–∏—Å—Ç–µ–º—É:

```bash
python main.py
```

üîß –û—Å–Ω–æ–≤–Ω—ñ —Ñ—É–Ω–∫—Ü—ñ—ó:

1. –î–æ–¥–∞–≤–∞–Ω–Ω—è –±–æ—Ç—ñ–≤: –ú–∞—Å–æ–≤–µ –¥–æ–¥–∞–≤–∞–Ω–Ω—è —á–µ—Ä–µ–∑ –Ω–æ–º–µ—Ä–∏ —Ç–µ–ª–µ—Ñ–æ–Ω—ñ–≤
2. –ü–∞—Ä—Å–∏–Ω–≥: –ì–µ–æ–ø–æ—à—É–∫ —á–∞—Ç—ñ–≤, –∞–Ω–∞–ª—ñ–∑ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ
3. –ê–Ω–∞–ª—ñ–∑ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤: –î–µ—Ç–∞–ª—å–Ω–∏–π OSINT –∞–Ω–∞–ª—ñ–∑
4. –†–æ–∑—Å–∏–ª–∫–∏: –¢–∞—Ä–≥–µ—Ç–æ–≤–∞–Ω—ñ –∫–∞–º–ø–∞–Ω—ñ—ó –∑ –ø–ª–∞–Ω—É–≤–∞–Ω–Ω—è–º
5. –ú–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥: –í—ñ–¥—Å—Ç–µ–∂–µ–Ω–Ω—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—ñ –≤ —Ä–µ–∞–ª—å–Ω–æ–º—É —á–∞—Å—ñ

